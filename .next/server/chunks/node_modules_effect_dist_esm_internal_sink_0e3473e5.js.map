{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"sink.js","sources":["file:///Users/nathan/Desktop/next/showStack/node_modules/effect/src/internal/sink.ts"],"sourcesContent":["import * as Arr from \"../Array.js\"\nimport * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport type * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Exit from \"../Exit.js\"\nimport { constTrue, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as Sink from \"../Sink.js\"\nimport type * as Types from \"../Types.js\"\nimport * as channel from \"./channel.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as core from \"./core-stream.js\"\n\n/** @internal */\nexport const SinkTypeId: Sink.SinkTypeId = Symbol.for(\"effect/Sink\") as Sink.SinkTypeId\n\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _L: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class SinkImpl<out A, in In = unknown, out L = never, out E = never, out R = never>\n  implements Sink.Sink<A, In, L, E, R>\n{\n  readonly [SinkTypeId] = sinkVariance\n  constructor(\n    readonly channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n  ) {\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isSink = (u: unknown): u is Sink.Sink<unknown, unknown, unknown, unknown, unknown> =>\n  hasProperty(u, SinkTypeId)\n\n/** @internal */\nexport const suspend = <A, In, L, E, R>(evaluate: LazyArg<Sink.Sink<A, In, L, E, R>>): Sink.Sink<A, In, L, E, R> =>\n  new SinkImpl(core.suspend(() => toChannel(evaluate())))\n\n/** @internal */\nexport const as = dual<\n  <A2>(a: A2) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, a: A2) => Sink.Sink<A2, In, L, E, R>\n>(\n  2,\n  (self, a) => pipe(self, map(() => a))\n)\n\n/** @internal */\nexport const collectAll = <In>(): Sink.Sink<Chunk.Chunk<In>, In> => new SinkImpl(collectAllLoop(Chunk.empty()))\n\n/** @internal */\nconst collectAllLoop = <In>(\n  acc: Chunk.Chunk<In>\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => collectAllLoop(pipe(acc, Chunk.appendAll(chunk))),\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllN = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  suspend(() => fromChannel(collectAllNLoop(n, Chunk.empty())))\n\n/** @internal */\nconst collectAllNLoop = <In>(\n  n: number,\n  acc: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = Chunk.splitAt(chunk, n)\n      if (collected.length < n) {\n        return collectAllNLoop(n - collected.length, Chunk.appendAll(acc, collected))\n      }\n      if (Chunk.isEmpty(leftovers)) {\n        return core.succeed(Chunk.appendAll(acc, collected))\n      }\n      return core.flatMap(core.write(leftovers), () => core.succeed(Chunk.appendAll(acc, collected)))\n    },\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllFrom = <A, In, L extends In, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<Chunk.Chunk<A>, In, L, E, R> =>\n  collectAllWhileWith(self, {\n    initial: Chunk.empty<A>(),\n    while: constTrue,\n    body: (chunk, a) => pipe(chunk, Chunk.append(a))\n  })\n\n/** @internal */\nexport const collectAllToMap = <In, K>(\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In> => {\n  return pipe(\n    foldLeftChunks(HashMap.empty<K, In>(), (map, chunk) =>\n      pipe(\n        chunk,\n        Chunk.reduce(map, (map, input) => {\n          const k: K = key(input)\n          const v: In = pipe(map, HashMap.has(k)) ?\n            merge(pipe(map, HashMap.unsafeGet(k)), input) :\n            input\n          return pipe(map, HashMap.set(k, v))\n        })\n      ))\n  )\n}\n\n/** @internal */\nexport const collectAllToMapN = <In, K>(\n  n: number,\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In, In> => {\n  return foldWeighted<HashMap.HashMap<K, In>, In>({\n    initial: HashMap.empty(),\n    maxCost: n,\n    cost: (acc, input) => pipe(acc, HashMap.has(key(input))) ? 0 : 1,\n    body: (acc, input) => {\n      const k: K = key(input)\n      const v: In = pipe(acc, HashMap.has(k)) ?\n        merge(pipe(acc, HashMap.unsafeGet(k)), input) :\n        input\n      return pipe(acc, HashMap.set(k, v))\n    }\n  })\n}\n\n/** @internal */\nexport const collectAllToSet = <In>(): Sink.Sink<HashSet.HashSet<In>, In> =>\n  foldLeftChunks<HashSet.HashSet<In>, In>(\n    HashSet.empty(),\n    (acc, chunk) => pipe(chunk, Chunk.reduce(acc, (acc, input) => pipe(acc, HashSet.add(input))))\n  )\n\n/** @internal */\nexport const collectAllToSetN = <In>(n: number): Sink.Sink<HashSet.HashSet<In>, In, In> =>\n  foldWeighted<HashSet.HashSet<In>, In>({\n    initial: HashSet.empty(),\n    maxCost: n,\n    cost: (acc, input) => HashSet.has(acc, input) ? 0 : 1,\n    body: (acc, input) => HashSet.add(acc, input)\n  })\n\n/** @internal */\nexport const collectAllUntil = <In>(p: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> => {\n  return pipe(\n    fold<[Chunk.Chunk<In>, boolean], In>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => [pipe(chunk, Chunk.append(input)), !p(input)]\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllUntilEffect = <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => {\n  return pipe(\n    foldEffect<[Chunk.Chunk<In>, boolean], In, E, R>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => pipe(p(input), Effect.map((bool) => [pipe(chunk, Chunk.append(input)), !bool]))\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllWhile: {\n  <In, Out extends In>(refinement: Refinement<In, Out>): Sink.Sink<Chunk.Chunk<Out>, In, In>\n  <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In>\n} = <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  fromChannel(collectAllWhileReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileReader = <In>(\n  predicate: Predicate<In>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = pipe(Chunk.toReadonlyArray(input), Arr.span(predicate))\n      if (leftovers.length === 0) {\n        return collectAllWhileReader(\n          predicate,\n          pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))\n        )\n      }\n      return pipe(\n        core.write(Chunk.unsafeFromArray(leftovers)),\n        channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))))\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<Chunk.Chunk<In>, In, In, E, R> => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, never, Chunk.Chunk<In>, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(pipe(input, Effect.takeWhile(predicate), Effect.map(Chunk.unsafeFromArray))),\n        core.flatMap((collected) => {\n          const leftovers = pipe(input, Chunk.drop(collected.length))\n          if (Chunk.isEmpty(leftovers)) {\n            return collectAllWhileEffectReader(predicate, pipe(done, Chunk.appendAll(collected)))\n          }\n          return pipe(core.write(leftovers), channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(collected)))))\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileWith: {\n  <A, S>(\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<S, In, L, E, R>\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R>\n} = dual(\n  2,\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R> => {\n    const refs = pipe(\n      Ref.make(Chunk.empty<In>()),\n      Effect.zip(Ref.make(false))\n    )\n    const newChannel = pipe(\n      core.fromEffect(refs),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        return pipe(\n          upstreamMarker,\n          core.pipeTo(channel.bufferChunk(leftoversRef)),\n          core.pipeTo(\n            collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)\n          )\n        )\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\nconst collectAllWhileWithLoop = <Z, In, L extends In, E, R, S>(\n  self: Sink.Sink<Z, In, L, E, R>,\n  leftoversRef: Ref.Ref<Chunk.Chunk<In>>,\n  upstreamDoneRef: Ref.Ref<boolean>,\n  currentResult: S,\n  p: Predicate<Z>,\n  f: (s: S, z: Z) => S\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, S, unknown, R> => {\n  return pipe(\n    toChannel(self),\n    channel.doneCollect,\n    channel.foldChannel({\n      onFailure: core.fail,\n      onSuccess: ([leftovers, doneValue]) =>\n        p(doneValue)\n          ? pipe(\n            core.fromEffect(\n              Ref.set(leftoversRef, Chunk.flatten(leftovers as Chunk.Chunk<Chunk.Chunk<In>>))\n            ),\n            core.flatMap(() =>\n              pipe(\n                core.fromEffect(Ref.get(upstreamDoneRef)),\n                core.flatMap((upstreamDone) => {\n                  const accumulatedResult = f(currentResult, doneValue)\n                  return upstreamDone\n                    ? pipe(core.write(Chunk.flatten(leftovers)), channel.as(accumulatedResult))\n                    : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f)\n                })\n              )\n            )\n          )\n          : pipe(core.write(Chunk.flatten(leftovers)), channel.as(currentResult))\n    })\n  )\n}\n\n/** @internal */\nexport const collectLeftover = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Chunk.Chunk<L>], In, never, E, R> =>\n  new SinkImpl(pipe(core.collectElements(toChannel(self)), channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])))\n\n/** @internal */\nexport const mapInput = dual<\n  <In0, In>(f: (input: In0) => In) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In): Sink.Sink<A, In0, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.map(f)))\n)\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <In0, In, E2, R2>(\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> =>\n    mapInputChunksEffect(\n      self,\n      (chunk) =>\n        Effect.map(\n          Effect.forEach(chunk, (v) => f(v)),\n          Chunk.unsafeFromArray\n        )\n    )\n)\n\n/** @internal */\nexport const mapInputChunks = dual<\n  <In0, In>(\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ): Sink.Sink<A, In0, L, E, R> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, never, never, unknown, unknown, R> = core.readWith({\n      onInput: (chunk) => pipe(core.write(f(chunk)), core.flatMap(() => loop)),\n      onFailure: core.fail,\n      onDone: core.succeed\n    })\n    return new SinkImpl(pipe(loop, core.pipeTo(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const mapInputChunksEffect = dual<\n  <In0, In, E2, R2>(\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, E2, never, unknown, unknown, R | R2> = core\n      .readWith({\n        onInput: (chunk) => pipe(core.fromEffect(f(chunk)), core.flatMap(core.write), core.flatMap(() => loop)),\n        onFailure: core.fail,\n        onDone: core.succeed\n      })\n    return new SinkImpl(pipe(loop, channel.pipeToOrFail(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const die = (defect: unknown): Sink.Sink<never, unknown> => failCause(Cause.die(defect))\n\n/** @internal */\nexport const dieMessage = (message: string): Sink.Sink<never, unknown> =>\n  failCause(Cause.die(new Cause.RuntimeException(message)))\n\n/** @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Sink.Sink<never, unknown> =>\n  failCauseSync(() => Cause.die(evaluate()))\n\n/** @internal */\nexport const dimap = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ): Sink.Sink<A2, In0, L, E, R> => map(mapInput(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const dimapEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) =>\n    mapEffect(\n      mapInputEffect(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunks = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  (self, options) =>\n    map(\n      mapInputChunks(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunksEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) => mapEffect(mapInputChunksEffect(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const drain: Sink.Sink<void, unknown> = new SinkImpl(\n  channel.drain(channel.identityChannel())\n)\n\n/** @internal */\nexport const drop = <In>(n: number): Sink.Sink<unknown, In, In> => suspend(() => new SinkImpl(dropLoop(n)))\n\n/** @internal */\nconst dropLoop = <In>(\n  n: number\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const dropped = pipe(input, Chunk.drop(n))\n      const leftover = Math.max(n - input.length, 0)\n      const more = Chunk.isEmpty(input) || leftover > 0\n      if (more) {\n        return dropLoop(leftover)\n      }\n      return pipe(\n        core.write(dropped),\n        channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>())\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropUntil = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(\n    pipe(toChannel(dropWhile((input: In) => !predicate(input))), channel.pipeToOrFail(toChannel(drop<In>(1))))\n  )\n\n/** @internal */\nexport const dropUntilEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)))\n\n/** @internal */\nconst dropUntilEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropUntil(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropUntilEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropWhile = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(dropWhileReader(predicate))\n\n/** @internal */\nconst dropWhileReader = <In>(\n  predicate: Predicate<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const out = pipe(input, Chunk.dropWhile(predicate))\n      if (Chunk.isEmpty(out)) {\n        return dropWhileReader(predicate)\n      }\n      return pipe(core.write(out), channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>()))\n    },\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const dropWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)))\n\n/** @internal */\nconst dropWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropWhile(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropWhileEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const ensuring = dual<\n  <X, R2>(\n    finalizer: Effect.Effect<X, never, R2>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, channel.ensuring(finalizer)))\n)\n\n/** @internal */\nexport const ensuringWith = dual<\n  <A, E, X, R2>(\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, core.ensuringWith(finalizer)))\n)\n\n/** @internal */\nexport const context = <R>(): Sink.Sink<Context.Context<R>, unknown, never, never, R> => fromEffect(Effect.context<R>())\n\n/** @internal */\nexport const contextWith = <R, Z>(\n  f: (context: Context.Context<R>) => Z\n): Sink.Sink<Z, unknown, never, never, R> => pipe(context<R>(), map(f))\n\n/** @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Sink.Sink<A, unknown, never, E, R0 | R> => pipe(context<R0>(), mapEffect(f))\n\n/** @internal */\nexport const contextWithSink = <R0, A, In, L, E, R>(\n  f: (context: Context.Context<R0>) => Sink.Sink<A, In, L, E, R>\n): Sink.Sink<A, In, L, E, R0 | R> =>\n  new SinkImpl(channel.unwrap(pipe(Effect.contextWith((context) => toChannel(f(context))))))\n\n/** @internal */\nexport const every = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(true, identity, (acc, input) => acc && predicate(input))\n\n/** @internal */\nexport const fail = <E>(e: E): Sink.Sink<never, unknown, never, E> => new SinkImpl(core.fail(e))\n\n/** @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failSync(evaluate))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCause(cause))\n\n/** @internal */\nexport const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCauseSync(evaluate))\n\n/** @internal */\nexport const filterInput: {\n  <In, In1 extends In, In2 extends In1>(\n    f: Refinement<In1, In2>\n  ): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In2, L, E, R>\n  <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E, R>\n} = <In, In1 extends In>(f: Predicate<In1>) => {\n  return <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In1, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.filter(f)))\n}\n\n/** @internal */\nexport const filterInputEffect = dual<\n  <In, In1 extends In, E2, R2>(\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In1 extends In, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<A, In1, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) =>\n    mapInputChunksEffect(\n      self,\n      (chunk) => Effect.map(Effect.filter(chunk, f), Chunk.unsafeFromArray)\n    )\n)\n\n/** @internal */\nexport const findEffect = dual<\n  <A, E2, R2>(\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R> => {\n    const newChannel = pipe(\n      core.fromEffect(pipe(\n        Ref.make(Chunk.empty<In>()),\n        Effect.zip(Ref.make(false))\n      )),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        const loop: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E | E2, never, Option.Option<A>, unknown, R | R2> =\n          channel.foldChannel(core.collectElements(toChannel(self)), {\n            onFailure: core.fail,\n            onSuccess: ([leftovers, doneValue]) =>\n              pipe(\n                core.fromEffect(f(doneValue)),\n                core.flatMap((satisfied) =>\n                  pipe(\n                    core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers))),\n                    channel.zipRight(\n                      pipe(\n                        core.fromEffect(Ref.get(upstreamDoneRef)),\n                        core.flatMap((upstreamDone) => {\n                          if (satisfied) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.some(doneValue)))\n                          }\n                          if (upstreamDone) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.none()))\n                          }\n                          return loop\n                        })\n                      )\n                    )\n                  )\n                )\n              )\n          })\n        return pipe(upstreamMarker, core.pipeTo(channel.bufferChunk(leftoversRef)), core.pipeTo(loop))\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const fold = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => S\n): Sink.Sink<S, In, In> => suspend(() => new SinkImpl(foldReader(s, contFn, f)))\n\n/** @internal */\nconst foldReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length)\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.as(nextS))\n      }\n      return foldReader(nextS, contFn, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplit = <S, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S,\n  index: number,\n  length: number\n): [S, Chunk.Chunk<In>] => {\n  if (index === length) {\n    return [s, Chunk.empty()]\n  }\n  const s1 = f(s, pipe(chunk, Chunk.unsafeGet(index)))\n  if (contFn(s1)) {\n    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length)\n  }\n  return [s1, pipe(chunk, Chunk.drop(index + 1))]\n}\n\n/** @internal */\nexport const foldSink = dual<\n  <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => <L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (z: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ): Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2> => {\n    const newChannel: Channel.Channel<\n      Chunk.Chunk<L1 | L2>,\n      Chunk.Chunk<In1 & In2>,\n      E1 | E2,\n      never,\n      A1 | A2,\n      unknown,\n      R | R1 | R2\n    > = pipe(\n      toChannel(self),\n      core.collectElements,\n      channel.foldChannel({\n        onFailure: (error) => toChannel(options.onFailure(error)),\n        onSuccess: ([leftovers, z]) =>\n          core.suspend(() => {\n            const leftoversRef = {\n              ref: pipe(leftovers, Chunk.filter(Chunk.isNonEmpty)) as Chunk.Chunk<Chunk.Chunk<L1 | L2>>\n            }\n            const refReader = pipe(\n              core.sync(() => {\n                const ref = leftoversRef.ref\n                leftoversRef.ref = Chunk.empty()\n                return ref\n              }),\n              // This cast is safe because of the L1 >: L <: In1 bound. It follows that\n              // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].\n              core.flatMap((chunk) => channel.writeChunk(chunk as Chunk.Chunk<Chunk.Chunk<In1 & In2>>))\n            )\n            const passthrough = channel.identityChannel<Chunk.Chunk<In1 & In2>, never, unknown>()\n            const continuationSink = pipe(\n              refReader,\n              channel.zipRight(passthrough),\n              core.pipeTo(toChannel(options.onSuccess(z)))\n            )\n            return core.flatMap(\n              core.collectElements(continuationSink),\n              ([newLeftovers, z1]) =>\n                pipe(\n                  core.succeed(leftoversRef.ref),\n                  core.flatMap(channel.writeChunk),\n                  channel.zipRight(channel.writeChunk(newLeftovers)),\n                  channel.as(z1)\n                )\n            )\n          })\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const foldChunks = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => foldChunksReader(f(s, input), contFn, f),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldChunksEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksEffectReader = <S, R, E, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Channel.Channel<never, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(s, input)),\n        core.flatMap((s) => foldChunksEffectReader(s, contFn, f))\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldEffectReader = <S, In, R, E>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldChunkSplitEffect(s, input, contFn, f)),\n        core.flatMap(([nextS, leftovers]) =>\n          pipe(\n            leftovers,\n            Option.match({\n              onNone: () => foldEffectReader(nextS, contFn, f),\n              onSome: (leftover) => pipe(core.write(leftover), channel.as(nextS))\n            })\n          )\n        )\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplitEffect = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> =>\n  foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f)\n\n/** @internal */\nconst foldChunkSplitEffectInternal = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> => {\n  if (index === length) {\n    return Effect.succeed([s, Option.none()])\n  }\n  return pipe(\n    f(s, pipe(chunk, Chunk.unsafeGet(index))),\n    Effect.flatMap((s1) =>\n      contFn(s1) ?\n        foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) :\n        Effect.succeed([s1, Option.some(pipe(chunk, Chunk.drop(index + 1)))])\n    )\n  )\n}\n\n/** @internal */\nexport const foldLeft = <S, In>(s: S, f: (s: S, input: In) => S): Sink.Sink<S, In> =>\n  ignoreLeftover(fold(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftChunks = <S, In>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => foldChunks(s, constTrue, f)\n\n/** @internal */\nexport const foldLeftChunksEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, never, E, R> => ignoreLeftover(foldChunksEffect(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => foldEffect(s, constTrue, f)\n\n/** @internal */\nexport const foldUntil = <S, In>(s: S, max: number, f: (s: S, input: In) => S): Sink.Sink<S, In, In> =>\n  pipe(\n    fold<[S, number], In>(\n      [s, 0],\n      (tuple) => tuple[1] < max,\n      ([output, count], input) => [f(output, input), count + 1]\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldUntilEffect = <S, In, E, R>(\n  s: S,\n  max: number,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> =>\n  pipe(\n    foldEffect(\n      [s, 0 as number] as const,\n      (tuple) => tuple[1] < max,\n      ([output, count], input: In) => pipe(f(output, input), Effect.map((s) => [s, count + 1] as const))\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldWeighted = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  foldWeightedDecompose({\n    ...options,\n    decompose: Chunk.of\n  })\n\n/** @internal */\nexport const foldWeightedDecompose = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly decompose: (input: In) => Chunk.Chunk<In>\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeLoop(\n        options.initial,\n        0,\n        false,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body\n      )\n    )\n  )\n\n/** @internal */\nconst foldWeightedDecomposeLoop = <S, In>(\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(\n        input,\n        0,\n        s,\n        cost,\n        dirty,\n        max,\n        costFn,\n        decompose,\n        f\n      )\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n      }\n      if (cost > max) {\n        return core.succeedNow(nextS)\n      }\n      return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeFold = <In, S>(\n  input: Chunk.Chunk<In>,\n  index: number,\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): [S, number, boolean, Chunk.Chunk<In>] => {\n  if (index === input.length) {\n    return [s, cost, dirty, Chunk.empty<In>()]\n  }\n  const elem = pipe(input, Chunk.unsafeGet(index))\n  const total = cost + costFn(s, elem)\n  if (total <= max) {\n    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f)\n  }\n  const decomposed = decompose(elem)\n  if (decomposed.length <= 1 && !dirty) {\n    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n    // minimize \"injury\", we only allow this when we haven't added anything else\n    // to the aggregate (dirty = false).\n    return [f(s, elem), total, true, pipe(input, Chunk.drop(index + 1))]\n  }\n  if (decomposed.length <= 1 && dirty) {\n    // If the state is dirty and `elem` cannot be decomposed, we stop folding\n    // and include `elem` in the leftovers.\n    return [s, cost, dirty, pipe(input, Chunk.drop(index))]\n  }\n  // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n  // into the chunk we're processing and see if we can aggregate further.\n  const next = pipe(decomposed, Chunk.appendAll(pipe(input, Chunk.drop(index + 1))))\n  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f)\n}\n\n/** @internal */\nexport const foldWeightedDecomposeEffect = <S, In, E, R, E2, R2, E3, R3>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>\n  }\n): Sink.Sink<S, In, In, E | E2 | E3, R | R2 | R3> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeEffectLoop(\n        options.initial,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body,\n        0,\n        false\n      )\n    )\n  )\n\n/** @internal */\nexport const foldWeightedEffect = <S, In, E, R, E2, R2>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>\n  }\n): Sink.Sink<S, In, In, E | E2, R | R2> =>\n  foldWeightedDecomposeEffect({\n    ...options,\n    decompose: (input) => Effect.succeed(Chunk.of(input))\n  })\n\nconst foldWeightedDecomposeEffectLoop = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  cost: number,\n  dirty: boolean\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E | E2 | E3, E | E2 | E3, S, unknown, R | R2 | R3> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0)),\n        core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {\n          if (Chunk.isNonEmpty(leftovers)) {\n            return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n          }\n          if (cost > max) {\n            return core.succeedNow(nextS)\n          }\n          return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty)\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeEffectFold = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  input: Chunk.Chunk<In>,\n  dirty: boolean,\n  cost: number,\n  index: number\n): Effect.Effect<[S, number, boolean, Chunk.Chunk<In>], E | E2 | E3, R | R2 | R3> => {\n  if (index === input.length) {\n    return Effect.succeed([s, cost, dirty, Chunk.empty<In>()])\n  }\n  const elem = pipe(input, Chunk.unsafeGet(index))\n  return pipe(\n    costFn(s, elem),\n    Effect.map((newCost) => cost + newCost),\n    Effect.flatMap((total) => {\n      if (total <= max) {\n        return pipe(\n          f(s, elem),\n          Effect.flatMap((s) =>\n            foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1)\n          )\n        )\n      }\n      return pipe(\n        decompose(elem),\n        Effect.flatMap((decomposed) => {\n          if (decomposed.length <= 1 && !dirty) {\n            // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n            // minimize \"injury\", we only allow this when we haven't added anything else\n            // to the aggregate (dirty = false).\n            return pipe(\n              f(s, elem),\n              Effect.map((s) => [s, total, true, pipe(input, Chunk.drop(index + 1))])\n            )\n          }\n          if (decomposed.length <= 1 && dirty) {\n            // If the state is dirty and `elem` cannot be decomposed, we stop folding\n            // and include `elem` in th leftovers.\n            return Effect.succeed([s, cost, dirty, pipe(input, Chunk.drop(index))])\n          }\n          // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n          // into the chunk we're processing and see if we can aggregate further.\n          const next = pipe(decomposed, Chunk.appendAll(pipe(input, Chunk.drop(index + 1))))\n          return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0)\n        })\n      )\n    })\n  )\n}\n\n/** @internal */\nexport const flatMap = dual<\n  <A, A1, In, In1 extends In, L1, E1, R1>(\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>\n>(\n  2,\n  (self, f) => foldSink(self, { onFailure: fail, onSuccess: f })\n)\n\n/** @internal */\nexport const forEach = <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(core.fromEffect(Effect.forEach(input, (v) => f(v), { discard: true })), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachChunk = <In, X, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>\n): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => pipe(core.fromEffect(f(input)), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachWhile = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const process: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => forEachWhileReader(f, input, 0, input.length, process),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nconst forEachWhileReader = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>,\n  input: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  cont: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> => {\n  if (index === length) {\n    return cont\n  }\n  return pipe(\n    core.fromEffect(f(pipe(input, Chunk.unsafeGet(index)))),\n    core.flatMap((bool) =>\n      bool ?\n        forEachWhileReader(f, input, index + 1, length, cont) :\n        core.write(pipe(input, Chunk.drop(index)))\n    ),\n    channel.catchAll((error) => pipe(core.write(pipe(input, Chunk.drop(index))), channel.zipRight(core.fail(error))))\n  )\n}\n\n/** @internal */\nexport const forEachChunkWhile = <In, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const reader: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(input)),\n        core.flatMap((cont) => cont ? reader : core.void)\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n  return new SinkImpl(reader)\n}\n\n/** @internal */\nexport const fromChannel = <L, In, E, A, R>(\n  channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n): Sink.Sink<A, In, L, E, R> => new SinkImpl(channel)\n\n/** @internal */\nexport const fromEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Sink.Sink<A, unknown, never, E, R> =>\n  new SinkImpl(core.fromEffect(effect))\n\n/** @internal */\nexport const fromPubSub = <In>(\n  pubsub: PubSub.PubSub<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> => fromQueue(pubsub, options)\n\n/** @internal */\nexport const fromPush = <In, L0, R0, L, R>(\n  push: Effect.Effect<\n    (_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>,\n    never,\n    R\n  >\n): Sink.Sink<R0, In, L, L0, Exclude<R, Scope.Scope>> =>\n  new SinkImpl(channel.unwrapScoped(pipe(push, Effect.map(fromPushPull))))\n\nconst fromPushPull = <In, Z, E, L, R>(\n  push: (\n    option: Option.Option<Chunk.Chunk<In>>\n  ) => Effect.Effect<void, readonly [Either.Either<Z, E>, Chunk.Chunk<L>], R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, Z, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      channel.foldChannel(core.fromEffect(push(Option.some(input))), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () => fromPushPull(push)\n      }),\n    onFailure: core.fail,\n    onDone: () =>\n      channel.foldChannel(core.fromEffect(push(Option.none())), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () =>\n          core.fromEffect(\n            Effect.dieMessage(\n              \"BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues\"\n            )\n          )\n      })\n  })\n\n/** @internal */\nexport const fromQueue = <In>(\n  queue: Queue.Enqueue<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> =>\n  options?.shutdown ?\n    unwrapScoped(\n      Effect.map(\n        Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown),\n        fromQueue\n      )\n    ) :\n    forEachChunk((input: Chunk.Chunk<In>) => pipe(Queue.offerAll(queue, input)))\n\n/** @internal */\nexport const head = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  fold(\n    Option.none() as Option.Option<In>,\n    Option.isNone,\n    (option, input) =>\n      Option.match(option, {\n        onNone: () => Option.some(input),\n        onSome: () => option\n      })\n  )\n\n/** @internal */\nexport const ignoreLeftover = <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In, never, E, R> =>\n  new SinkImpl(channel.drain(toChannel(self)))\n\n/** @internal */\nexport const last = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  foldLeftChunks(Option.none<In>(), (s, input) => Option.orElse(Chunk.last(input), () => s))\n\n/** @internal */\nexport const leftover = <L>(chunk: Chunk.Chunk<L>): Sink.Sink<void, unknown, L> =>\n  new SinkImpl(core.suspend(() => core.write(chunk)))\n\n/** @internal */\nexport const map = dual<\n  <A, A2>(f: (a: A) => A2) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, f: (a: A) => A2) => Sink.Sink<A2, In, L, E, R>\n>(2, (self, f) => {\n  return new SinkImpl(pipe(toChannel(self), channel.map(f)))\n})\n\n/** @internal */\nexport const mapEffect = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Sink.Sink<A2, In, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapEffect(f)))\n)\n\n/** @internal */\nexport const mapError = dual<\n  <E, E2>(f: (error: E) => E2) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(self: Sink.Sink<A, In, L, E, R>, f: (error: E) => E2) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapError(f)))\n)\n\n/** @internal */\nexport const mapLeftover = dual<\n  <L, L2>(f: (leftover: L) => L2) => <A, In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L2, E, R>,\n  <A, In, L, E, R, L2>(self: Sink.Sink<A, In, L, E, R>, f: (leftover: L) => L2) => Sink.Sink<A, In, L2, E, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapOut(Chunk.map(f))))\n)\n\n/** @internal */\nexport const never: Sink.Sink<never, unknown> = fromEffect(Effect.never)\n\n/** @internal */\nexport const orElse = dual<\n  <A2, In2, L2, E2, R2>(\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ): Sink.Sink<A | A2, In & In2, L | L2, E | E2, R | R2> =>\n    new SinkImpl<A | A2, In & In2, L | L2, E | E2, R | R2>(\n      pipe(toChannel(self), channel.orElse(() => toChannel(that())))\n    )\n)\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, In, L, E>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E>,\n  <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>, context: Context.Context<R>) => Sink.Sink<A, In, L, E>\n>(\n  2,\n  (self, context) => new SinkImpl(pipe(toChannel(self), core.provideContext(context)))\n)\n\n/** @internal */\nexport const race = dual<\n  <R1, E1, In1, L1, A1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  2,\n  (self, that) => pipe(self, raceBoth(that), map(Either.merge))\n)\n\n/** @internal */\nexport const raceBoth = dual<\n  <A1, In1, L1, E1, R1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => <A, In, L, E, R>(\n    self: Sink.Sink<A, In, L, E, R>\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  (args) => isSink(args[1]),\n  (self, that, options) =>\n    raceWith(self, {\n      other: that,\n      onSelfDone: (selfDone) => mergeDecision.Done(Effect.map(selfDone, Either.left)),\n      onOtherDone: (thatDone) => mergeDecision.Done(Effect.map(thatDone, Either.right)),\n      capacity: options?.capacity ?? 16\n    })\n)\n\n/** @internal */\nexport const raceWith = dual<\n  <A2, In2, L2, E2, R2, A, E, A3, A4>(\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ): Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R> => {\n    function race(scope: Scope.Scope) {\n      return Effect.gen(function*() {\n        const pubsub = yield* PubSub.bounded<\n          Either.Either<Chunk.Chunk<In & In2>, Exit.Exit<unknown>>\n        >(options?.capacity ?? 16)\n        const subscription1 = yield* Scope.extend(PubSub.subscribe(pubsub), scope)\n        const subscription2 = yield* Scope.extend(PubSub.subscribe(pubsub), scope)\n        const reader = channel.toPubSub(pubsub)\n        const writer = channel.fromQueue(subscription1).pipe(\n          core.pipeTo(toChannel(self)),\n          channel.zipLeft(core.fromEffect(Queue.shutdown(subscription1))),\n          channel.mergeWith({\n            other: channel.fromQueue(subscription2).pipe(\n              core.pipeTo(toChannel(options.other)),\n              channel.zipLeft(core.fromEffect(Queue.shutdown(subscription2)))\n            ),\n            onSelfDone: options.onSelfDone,\n            onOtherDone: options.onOtherDone\n          })\n        )\n        const racedChannel = channel.mergeWith(reader, {\n          other: writer,\n          onSelfDone: () => mergeDecision.Await(identity),\n          onOtherDone: (exit) => mergeDecision.Done(exit)\n        }) as Channel.Channel<\n          Chunk.Chunk<L | L2>,\n          Chunk.Chunk<In & In2>,\n          E | E2,\n          never,\n          A3 | A4,\n          unknown,\n          R | R2\n        >\n        return new SinkImpl(racedChannel)\n      })\n    }\n    return unwrapScopedWith(race)\n  }\n)\n\n/** @internal */\nexport const refineOrDie = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, pf) => pipe(self, refineOrDieWith(pf, identity))\n)\n\n/** @internal */\nexport const refineOrDieWith = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  3,\n  (self, pf, f) => {\n    const newChannel = pipe(\n      self,\n      toChannel,\n      channel.catchAll((error) =>\n        Option.match(pf(error), {\n          onNone: () => core.failCauseSync(() => Cause.die(f(error))),\n          onSome: core.fail\n        })\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const service = <I, S>(\n  tag: Context.Tag<I, S>\n): Sink.Sink<S, unknown, never, never, I> => serviceWith(tag, identity)\n\n/** @internal */\nexport const serviceWith = <I, S, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Z\n): Sink.Sink<Z, unknown, never, never, I> => fromEffect(Effect.map(tag, f))\n\n/** @internal */\nexport const serviceWithEffect = <I, S, R, E, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Effect.Effect<Z, E, R>\n): Sink.Sink<Z, unknown, never, E, R | I> => fromEffect(Effect.flatMap(tag, f))\n\n/** @internal */\nexport const serviceWithSink = <I, S, R, E, In, L, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Sink.Sink<Z, In, L, E, R>\n): Sink.Sink<Z, In, L, E, R | I> =>\n  new SinkImpl(pipe(Effect.map(tag, (service) => toChannel(f(service))), channel.unwrap))\n\n/** @internal */\nexport const some = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(false, (bool) => !bool, (acc, input) => acc || predicate(input))\n\n/** @internal */\nexport const splitWhere = dual<\n  <In>(f: Predicate<In>) => <A, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, In, E, R>,\n  <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>) => Sink.Sink<A, In, In, E, R>\n>(2, <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>): Sink.Sink<A, In, In, E, R> => {\n  const newChannel = pipe(\n    core.fromEffect(Ref.make(Chunk.empty<In>())),\n    core.flatMap((ref) =>\n      pipe(\n        splitWhereSplitter<In, E>(false, ref, f),\n        channel.pipeToOrFail(toChannel(self)),\n        core.collectElements,\n        core.flatMap(([leftovers, z]) =>\n          pipe(\n            core.fromEffect(Ref.get(ref)),\n            core.flatMap((leftover) =>\n              pipe(\n                core.write<Chunk.Chunk<In>>(pipe(leftover, Chunk.appendAll(Chunk.flatten(leftovers)))),\n                channel.zipRight(core.succeed(z))\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n  return new SinkImpl(newChannel)\n})\n\n/** @internal */\nconst splitWhereSplitter = <A, E>(\n  written: boolean,\n  leftovers: Ref.Ref<Chunk.Chunk<A>>,\n  f: Predicate<A>\n): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, never, unknown, unknown> =>\n  core.readWithCause({\n    onInput: (input) => {\n      if (Chunk.isEmpty(input)) {\n        return splitWhereSplitter(written, leftovers, f)\n      }\n      if (written) {\n        const index = indexWhere(input, f)\n        if (index === -1) {\n          return channel.zipRight(\n            core.write(input),\n            splitWhereSplitter<A, E>(true, leftovers, f)\n          )\n        }\n        const [left, right] = Chunk.splitAt(input, index)\n        return channel.zipRight(\n          core.write(left),\n          core.fromEffect(Ref.set(leftovers, right))\n        )\n      }\n      const index = indexWhere(input, f, 1)\n      if (index === -1) {\n        return channel.zipRight(\n          core.write(input),\n          splitWhereSplitter<A, E>(true, leftovers, f)\n        )\n      }\n      const [left, right] = pipe(input, Chunk.splitAt(Math.max(index, 1)))\n      return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)))\n    },\n    onFailure: core.failCause,\n    onDone: core.succeed\n  })\n\n/** @internal */\nconst indexWhere = <A>(self: Chunk.Chunk<A>, predicate: Predicate<A>, from = 0): number => {\n  const iterator = self[Symbol.iterator]()\n  let index = 0\n  let result = -1\n  let next: IteratorResult<A, any>\n  while (result < 0 && (next = iterator.next()) && !next.done) {\n    const a = next.value\n    if (index >= from && predicate(a)) {\n      result = index\n    }\n    index = index + 1\n  }\n  return result\n}\n\n/** @internal */\nexport const succeed = <A>(a: A): Sink.Sink<A, unknown> => new SinkImpl(core.succeed(a))\n\n/** @internal */\nexport const sum: Sink.Sink<number, number> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + Chunk.reduce(chunk, 0, (s, a) => s + a)\n)\n\n/** @internal */\nexport const summarized = dual<\n  <A2, E2, R2, A3>(\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>\n>(\n  3,\n  (self, summary, f) => {\n    const newChannel = pipe(\n      core.fromEffect(summary),\n      core.flatMap((start) =>\n        pipe(\n          self,\n          toChannel,\n          core.flatMap((done) =>\n            pipe(\n              core.fromEffect(summary),\n              channel.map((end) => [done, f(start, end)])\n            )\n          )\n        )\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Sink.Sink<A, unknown> => new SinkImpl(core.sync(evaluate))\n\n/** @internal */\nexport const take = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  pipe(\n    foldChunks<Chunk.Chunk<In>, In>(\n      Chunk.empty(),\n      (chunk) => chunk.length < n,\n      (acc, chunk) => pipe(acc, Chunk.appendAll(chunk))\n    ),\n    flatMap((acc) => {\n      const [taken, leftover] = pipe(acc, Chunk.splitAt(n))\n      return new SinkImpl(pipe(core.write(leftover), channel.zipRight(core.succeedNow(taken))))\n    })\n  )\n\n/** @internal */\nexport const toChannel = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R> =>\n  Effect.isEffect(self) ?\n    toChannel(fromEffect(self as Effect.Effect<A, E, R>)) :\n    (self as SinkImpl<A, In, L, E, R>).channel\n\n/** @internal */\nexport const unwrap = <A, In, L, E2, R2, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E2, R2>, E, R>\n): Sink.Sink<A, In, L, E | E2, R | R2> =>\n  new SinkImpl(\n    channel.unwrap(pipe(effect, Effect.map((sink) => toChannel(sink))))\n  )\n\n/** @internal */\nexport const unwrapScoped = <A, In, L, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E, R>, E, R>\n): Sink.Sink<A, In, L, E, Exclude<R, Scope.Scope>> =>\n  new SinkImpl(\n    channel.unwrapScoped(effect.pipe(\n      Effect.map((sink) => toChannel(sink))\n    ))\n  )\n\n/** @internal */\nexport const unwrapScopedWith = <A, In, L, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<Sink.Sink<A, In, L, E, R>, E, R>\n): Sink.Sink<A, In, L, E, R> =>\n  new SinkImpl(\n    channel.unwrapScopedWith((scope) =>\n      f(scope).pipe(\n        Effect.map((sink) => toChannel(sink))\n      )\n    )\n  )\n\n/** @internal */\nexport const withDuration = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Duration.Duration], In, L, E, R> =>\n  pipe(self, summarized(Clock.currentTimeMillis, (start, end) => Duration.millis(end - start)))\n\n/** @internal */\nexport const zip = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, z2) => [z, z2], options)\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, _) => z, options)\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (_, z2) => z2, options)\n)\n\n/** @internal */\nexport const zipWith = dual<\n  <A2, In, In2 extends In, L2, E2, R2, A, A3>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R> =>\n    options?.concurrent ?\n      raceWith(self, {\n        other: that,\n        onSelfDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (leftZ) =>\n            mergeDecision.Await<R | R2, E2, A2, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (rightZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        }),\n        onOtherDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (rightZ) =>\n            mergeDecision.Await<R | R2, E, A, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (leftZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        })\n      }) :\n      flatMap(self, (z) => map(that, (z2) => f(z, z2)))\n)\n\n// Circular with Channel\n\n/** @internal */\nexport const channelToSink = <OutElem, InElem, OutErr, InErr, OutDone, Env>(\n  self: Channel.Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>\n): Sink.Sink<OutDone, InElem, OutElem, OutErr, Env> => new SinkImpl(self)\n\n// Constants\n\n/** @internal */\nexport const count: Sink.Sink<number, unknown> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + chunk.length\n)\n\n/** @internal */\nexport const mkString: Sink.Sink<string, unknown> = suspend(() => {\n  const strings: Array<string> = []\n  return pipe(\n    foldLeftChunks<void, unknown>(void 0, (_, elems) =>\n      Chunk.map(elems, (elem) => {\n        strings.push(String(elem))\n      })),\n    map(() => strings.join(\"\"))\n  )\n})\n\n/** @internal */\nexport const timed: Sink.Sink<Duration.Duration, unknown> = pipe(\n  withDuration(drain),\n  map((tuple) => tuple[1])\n)\n"],"names":["Arr","Cause","Chunk","Clock","Duration","Effect","Either","Exit","constTrue","dual","identity","pipe","HashMap","HashSet","Option","pipeArguments","hasProperty","PubSub","Queue","Ref","Scope","channel","mergeDecision","core","SinkTypeId","Symbol","for","sinkVariance","_A","_","_In","_L","_E","_R","SinkImpl","constructor","arguments","isSink","u","suspend","evaluate","toChannel","as","self","a","map","collectAll","collectAllLoop","empty","acc","readWithCause","onInput","chunk","appendAll","onFailure","failCause","onDone","succeed","collectAllN","n","fromChannel","collectAllNLoop","collected","leftovers","splitAt","length","isEmpty","flatMap","write","collectAllFrom","collectAllWhileWith","initial","while","body","append","collectAllToMap","key","merge","foldLeftChunks","reduce","input","k","v","has","unsafeGet","set","collectAllToMapN","foldWeighted","maxCost","cost","collectAllToSet","add","collectAllToSetN","collectAllUntil","p","fold","tuple","collectAllUntilEffect","foldEffect","bool","collectAllWhile","predicate","collectAllWhileReader","done","readWith","toReadonlyArray","span","unsafeFromArray","zipRight","fail","collectAllWhileEffect","collectAllWhileEffectReader","fromEffect","takeWhile","drop","options","refs","make","zip","newChannel","leftoversRef","upstreamDoneRef","upstreamMarker","pipeTo","bufferChunk","collectAllWhileWithLoop","currentResult","f","doneCollect","foldChannel","onSuccess","doneValue","flatten","get","upstreamDone","accumulatedResult","collectLeftover","collectElements","chunks","z","mapInput","mapInputChunks","mapInputEffect","mapInputChunksEffect","forEach","loop","pipeToOrFail","die","defect","dieMessage","message","RuntimeException","dieSync","failCauseSync","dimap","dimapEffect","mapEffect","dimapChunks","dimapChunksEffect","drain","identityChannel","dropLoop","dropped","leftover","Math","max","more","void","dropUntil","dropWhile","dropUntilEffect","dropUntilEffectReader","unwrap","dropWhileReader","out","succeedNow","dropWhileEffect","dropWhileEffectReader","ensuring","finalizer","ensuringWith","context","contextWith","contextWithEffect","contextWithSink","every","e","failSync","cause","filterInput","filter","filterInputEffect","findEffect","satisfied","some","none","s","contFn","foldReader","nextS","foldChunkSplit","isNonEmpty","index","s1","foldSink","error","ref","refReader","sync","writeChunk","passthrough","continuationSink","newLeftovers","z1","foldChunks","foldChunksReader","foldChunksEffect","foldChunksEffectReader","foldEffectReader","foldChunkSplitEffect","match","onNone","onSome","foldChunkSplitEffectInternal","foldLeft","ignoreLeftover","foldLeftChunksEffect","foldLeftEffect","foldUntil","output","count","foldUntilEffect","foldWeightedDecompose","decompose","of","foldWeightedDecomposeLoop","dirty","costFn","nextCost","nextDirty","foldWeightedDecomposeFold","elem","total","decomposed","next","foldWeightedDecomposeEffect","foldWeightedDecomposeEffectLoop","foldWeightedEffect","foldWeightedDecomposeEffectFold","newCost","process","discard","forEachChunk","forEachWhile","forEachWhileReader","cont","catchAll","forEachChunkWhile","reader","effect","fromPubSub","pubsub","fromQueue","fromPush","push","unwrapScoped","fromPushPull","either","onLeft","onRight","queue","shutdown","acquireRelease","offerAll","head","isNone","option","last","orElse","mapError","mapLeftover","mapOut","never","that","provideContext","race","raceBoth","args","raceWith","other","onSelfDone","selfDone","Done","left","onOtherDone","thatDone","right","capacity","scope","gen","bounded","subscription1","extend","subscribe","subscription2","toPubSub","writer","zipLeft","mergeWith","racedChannel","Await","exit","unwrapScopedWith","refineOrDie","pf","refineOrDieWith","service","tag","serviceWith","serviceWithEffect","serviceWithSink","splitWhere","splitWhereSplitter","written","indexWhere","from","iterator","result","value","sum","summarized","summary","start","end","take","taken","isEffect","sink","withDuration","currentTimeMillis","millis","zipWith","z2","concurrent","leftZ","rightZ","channelToSink","mkString","strings","elems","String","join","timed"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}