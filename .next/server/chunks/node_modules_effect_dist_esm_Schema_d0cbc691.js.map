{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"Schema.js","sources":["file:///Users/nathan/Desktop/showStack/node_modules/effect/src/Schema.ts"],"sourcesContent":["/**\n * @since 3.10.0\n */\n\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from \"./Arbitrary.js\"\nimport * as array_ from \"./Array.js\"\nimport * as bigDecimal_ from \"./BigDecimal.js\"\nimport * as bigInt_ from \"./BigInt.js\"\nimport * as boolean_ from \"./Boolean.js\"\nimport type { Brand } from \"./Brand.js\"\nimport * as cause_ from \"./Cause.js\"\nimport * as chunk_ from \"./Chunk.js\"\nimport * as config_ from \"./Config.js\"\nimport * as configError_ from \"./ConfigError.js\"\nimport * as data_ from \"./Data.js\"\nimport * as dateTime from \"./DateTime.js\"\nimport * as duration_ from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as either_ from \"./Either.js\"\nimport * as Encoding from \"./Encoding.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport * as exit_ from \"./Exit.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as fiberId_ from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as hashMap_ from \"./HashMap.js\"\nimport * as hashSet_ from \"./HashSet.js\"\nimport * as internalCause_ from \"./internal/cause.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as schemaId_ from \"./internal/schema/schemaId.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as list_ from \"./List.js\"\nimport * as number_ from \"./Number.js\"\nimport * as option_ from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as pretty_ from \"./Pretty.js\"\nimport * as redacted_ from \"./Redacted.js\"\nimport * as Request from \"./Request.js\"\nimport * as scheduler_ from \"./Scheduler.js\"\nimport type { ParseOptions } from \"./SchemaAST.js\"\nimport * as AST from \"./SchemaAST.js\"\nimport * as sortedSet_ from \"./SortedSet.js\"\nimport * as string_ from \"./String.js\"\nimport * as struct_ from \"./Struct.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 3.10.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Schema\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.GenericSchema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function make<A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> {\n  return class SchemaClass {\n    [TypeId] = variance\n    static ast = ast\n    static annotations(annotations: Annotations.GenericSchema<A>) {\n      return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n    static toString() {\n      return String(ast)\n    }\n    static Type: A\n    static Encoded: I\n    static Context: R\n    static [TypeId] = variance\n  }\n}\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst makeStandardResult = <A>(exit: exit_.Exit<StandardSchemaV1.Result<A>>): StandardSchemaV1.Result<A> =>\n  exit_.isSuccess(exit) ? exit.value : makeStandardFailureResult(cause_.pretty(exit.cause))\n\nconst makeStandardFailureResult = (message: string): StandardSchemaV1.FailureResult => ({\n  issues: [{ message }]\n})\n\nconst makeStandardFailureFromParseIssue = (\n  issue: ParseResult.ParseIssue\n): Effect.Effect<StandardSchemaV1.FailureResult> =>\n  Effect.map(ParseResult.ArrayFormatter.formatIssue(issue), (issues) => ({\n    issues: issues.map((issue) => ({\n      path: issue.path,\n      message: issue.message\n    }))\n  }))\n\n/**\n * Returns a \"Standard Schema\" object conforming to the [Standard Schema\n * v1](https://standardschema.dev/) specification.\n *\n * This function creates a schema whose `validate` method attempts to decode and\n * validate the provided input synchronously. If the underlying `Schema`\n * includes any asynchronous components (e.g., asynchronous message resolutions\n * or checks), then validation will necessarily return a `Promise` instead.\n *\n * Any detected defects will be reported via a single issue containing no\n * `path`.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const schema = Schema.Struct({\n *   name: Schema.String\n * })\n *\n * //      ┌─── StandardSchemaV1<{ readonly name: string; }>\n * //      ▼\n * const standardSchema = Schema.standardSchemaV1(schema)\n * ```\n *\n * @category Standard Schema\n * @since 3.13.0\n */\nexport const standardSchemaV1 = <A, I>(\n  schema: Schema<A, I, never>,\n  overrideOptions?: AST.ParseOptions\n): StandardSchemaV1<I, A> & SchemaClass<A, I, never> => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, { errors: \"all\" })\n  return class StandardSchemaV1Class extends make<A, I, never>(schema.ast) {\n    static \"~standard\" = {\n      version: 1,\n      vendor: \"effect\",\n      validate(value) {\n        const scheduler = new scheduler_.SyncScheduler()\n        const fiber = Effect.runFork(\n          Effect.matchEffect(decodeUnknown(value, overrideOptions), {\n            onFailure: makeStandardFailureFromParseIssue,\n            onSuccess: (value) => Effect.succeed({ value })\n          }),\n          { scheduler }\n        )\n        scheduler.flush()\n        const exit = fiber.unsafePoll()\n        if (exit) {\n          return makeStandardResult(exit)\n        }\n        return new Promise((resolve) => {\n          fiber.addObserver((exit) => {\n            resolve(makeStandardResult(exit))\n          })\n        })\n      }\n    }\n  }\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst builtInAnnotations = {\n  schemaId: AST.SchemaIdAnnotationId,\n  message: AST.MessageAnnotationId,\n  missingMessage: AST.MissingMessageAnnotationId,\n  identifier: AST.IdentifierAnnotationId,\n  title: AST.TitleAnnotationId,\n  description: AST.DescriptionAnnotationId,\n  examples: AST.ExamplesAnnotationId,\n  default: AST.DefaultAnnotationId,\n  documentation: AST.DocumentationAnnotationId,\n  jsonSchema: AST.JSONSchemaAnnotationId,\n  arbitrary: AST.ArbitraryAnnotationId,\n  pretty: AST.PrettyAnnotationId,\n  equivalence: AST.EquivalenceAnnotationId,\n  concurrency: AST.ConcurrencyAnnotationId,\n  batching: AST.BatchingAnnotationId,\n  parseIssueTitle: AST.ParseIssueTitleAnnotationId,\n  parseOptions: AST.ParseOptionsAnnotationId,\n  decodingFallback: AST.DecodingFallbackAnnotationId\n}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = { ...annotations }\n\n  for (const key in builtInAnnotations) {\n    if (key in annotations) {\n      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]\n      out[id] = annotations[key as keyof typeof annotations]\n      delete out[key]\n    }\n  }\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 3.10.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport function asSchema<S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> {\n  return schema as any\n}\n\n/**\n * @category formatting\n * @since 3.10.0\n */\nexport const format = <S extends Schema.All>(schema: S): string => String(schema.ast)\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 3.10.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 3.10.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 3.10.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 3.10.0\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 3.10.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 3.10.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 3.10.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 3.10.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nfunction getDefaultLiteralAST<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n): AST.AST {\n  return AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n}\n\nfunction makeLiteralClass<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> {\n  return class LiteralClass extends make<Literals[number]>(ast) {\n    static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static literals = [...literals] as Literals\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): SchemaClass<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): SchemaClass<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Schema } from \"effect\"\n *\n * const schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 3.10.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {\n  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static enums = { ...enums }\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype AppendType<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer A extends AST.LiteralValue, infer _I, infer _R> ? `${Template}${A}`\n  : never\n\ntype GetTemplateLiteralType<Params> = Params extends [...infer Init, infer Last] ?\n  AppendType<GetTemplateLiteralType<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(\n  ...[head, ...tail]: Params\n): TemplateLiteral<GetTemplateLiteralType<Params>> => {\n  const spans: Array<AST.TemplateLiteralSpan> = []\n  let h = \"\"\n  let ts = tail\n\n  if (isSchema(head)) {\n    if (AST.isLiteral(head.ast)) {\n      h = String(head.ast.literal)\n    } else {\n      ts = [head, ...ts]\n    }\n  } else {\n    h = String(head)\n  }\n\n  for (let i = 0; i < ts.length; i++) {\n    const item = ts[i]\n    if (isSchema(item)) {\n      if (i < ts.length - 1) {\n        const next = ts[i + 1]\n        if (isSchema(next)) {\n          if (AST.isLiteral(next.ast)) {\n            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)))\n            i++\n            continue\n          }\n        } else {\n          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)))\n          i++\n          continue\n        }\n      }\n      spans.push(new AST.TemplateLiteralSpan(item.ast, \"\"))\n    } else {\n      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), \"\"))\n    }\n  }\n\n  if (array_.isNonEmptyArray(spans)) {\n    return make(new AST.TemplateLiteral(h, spans))\n  } else {\n    return make(new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(new AST.Literal(h), \"\")]))\n  }\n}\n\ntype TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue\n\ntype GetTemplateLiteralParserType<Params> = Params extends [infer Head, ...infer Tail] ? readonly [\n    Head extends Schema<infer A, infer _I, infer _R> ? A : Head,\n    ...GetTemplateLiteralParserType<Tail>\n  ]\n  : []\n\ntype AppendEncoded<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer _A, infer I extends AST.LiteralValue, infer _R> ? `${Template}${I}`\n  : never\n\ntype GetTemplateLiteralParserEncoded<Params> = Params extends [...infer Init, infer Last] ?\n  AppendEncoded<GetTemplateLiteralParserEncoded<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}\n\nfunction getTemplateLiteralParserCoercedElement(encoded: Schema.Any, schema: Schema.Any): Schema.Any | undefined {\n  const ast = encoded.ast\n  switch (ast._tag) {\n    case \"Literal\": {\n      const literal = ast.literal\n      if (!Predicate.isString(literal)) {\n        const s = String(literal)\n        return transform(Literal(s), schema, {\n          strict: true,\n          decode: () => literal,\n          encode: () => s\n        })\n      }\n      break\n    }\n    case \"NumberKeyword\":\n      return compose(NumberFromString, schema)\n    case \"Union\": {\n      const members: Array<Schema.Any> = []\n      let hasCoercions = false\n      for (const member of ast.types) {\n        const schema = make(member)\n        const encoded = encodedSchema(schema)\n        const coerced = getTemplateLiteralParserCoercedElement(encoded, schema)\n        if (coerced) {\n          hasCoercions = true\n        }\n        members.push(coerced ?? schema)\n      }\n      return hasCoercions ? compose(Union(...members), schema) : schema\n    }\n  }\n}\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(\n  ...params: Params\n): TemplateLiteralParser<Params> => {\n  const encodedSchemas: Array<Schema.Any> = []\n  const elements: Array<Schema.Any> = []\n  const schemas: Array<Schema.Any> = []\n  let coerced = false\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i]\n    const schema = isSchema(param) ? param : Literal(param)\n    schemas.push(schema)\n    const encoded = encodedSchema(schema)\n    encodedSchemas.push(encoded)\n    const element = getTemplateLiteralParserCoercedElement(encoded, schema)\n    if (element) {\n      elements.push(element)\n      coerced = true\n    } else {\n      elements.push(schema)\n    }\n  }\n  const from = TemplateLiteral(...encodedSchemas as any)\n  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)\n  let to = Tuple(...elements)\n  if (coerced) {\n    to = to.annotations({ [AST.AutoTitleAnnotationId]: format(Tuple(...schemas)) })\n  }\n  return class TemplateLiteralParserClass extends transformOrFail(from, to, {\n    strict: false,\n    decode: (i, _, ast) => {\n      const match = re.exec(i)\n      return match\n        ? ParseResult.succeed(match.slice(1, params.length + 1))\n        : ParseResult.fail(new ParseResult.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`))\n    },\n    encode: (tuple) => ParseResult.succeed(tuple.join(\"\"))\n  }) {\n    static params = params.slice()\n  } as any\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  makeDeclareClass(\n    typeParameters,\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return makeDeclareClass([], new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface declare<\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends AnnotableClass<declare<A, I, P, R>, A, I, R> {\n  readonly typeParameters: Readonly<P>\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface AnnotableDeclare<\n  Self extends declare<A, I, P, R>,\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends declare<A, I, P, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\nfunction makeDeclareClass<P extends ReadonlyArray<Schema.All>, A, I, R>(\n  typeParameters: P,\n  ast: AST.AST\n): declare<A, I, P, R> {\n  return class DeclareClass extends make<A, I, R>(ast) {\n    static override annotations(annotations: Annotations.Schema<A>): declare<A, I, P, R> {\n      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations))\n    }\n    static typeParameters = [...typeParameters] as any as P\n  }\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const declare: {\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A, I, const P extends ReadonlyArray<Schema.All>>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): declare<A, I, P>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BrandSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Brand\")\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> => {\n  const out = makeBrandClass(\n    self,\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({\n        schemaId: BrandSchemaId,\n        [BrandSchemaId]: { constructor },\n        ...annotations\n      })\n    )\n  )\n  return out as any\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const InstanceOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface instanceOf<A> extends AnnotableDeclare<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      schemaId: InstanceOfSchemaId,\n      [InstanceOfSchemaId]: { constructor },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n}\n\nconst getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>\n  AST.Union.make(members.map((m) => m.ast))\n\nfunction makeUnionClass<Members extends AST.Members<Schema.All>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<Members> {\n  return class UnionClass extends make<\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >(ast) {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static members = [...members]\n  }\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport function Union<Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.All>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n) {\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0]\n    : Never\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Element {\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 3.10.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 3.10.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 3.10.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nfunction makeTupleTypeClass<Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) {\n  return class TupleTypeClass extends make<\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n    ): TupleType<Elements, Rest> {\n      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static elements = [...elements] as any as Elements\n\n    static rest = [...rest] as any as Rest\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface Tuple2<Fst extends Schema.Any, Snd extends Schema.Any> extends\n  AnnotableClass<\n    Tuple2<Fst, Snd>,\n    readonly [Schema.Type<Fst>, Schema.Type<Snd>],\n    readonly [Schema.Encoded<Fst>, Schema.Encoded<Snd>],\n    Schema.Context<Fst> | Schema.Context<Snd>\n  >\n{\n  readonly elements: readonly [Fst, Snd]\n  readonly rest: readonly []\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Fst extends Schema.Any, Snd extends Schema.Any>(fst: Fst, snd: Snd): Tuple2<Fst, Snd>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nfunction makeArrayClass<Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): Array$<Value> {\n  return class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n}\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 3.10.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArray<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{\n  readonly elements: readonly [Value]\n  readonly rest: readonly [Value]\n  readonly value: Value\n}\n\nfunction makeNonEmptyArrayClass<Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n) {\n  return class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n    static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static value = value\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, Array$<Value>]>, Array$<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function ArrayEnsure<Value extends Schema.Any>(value: Value): ArrayEnsure<Value> {\n  return transform(Union(value, Array$(value)), Array$(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => array_.ensure(i),\n    encode: (a) => a.length === 1 ? a[0] : a\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, NonEmptyArray<Value>]>, NonEmptyArray<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function NonEmptyArrayEnsure<Value extends Schema.Any>(value: Value): NonEmptyArrayEnsure<Value> {\n  return transform(Union(value, NonEmptyArray(value)), NonEmptyArray(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => array_.isNonEmptyReadonlyArray(i) ? i : array_.of(i),\n    encode: (a) => a.length === 1 ? a[0] : a\n  })\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        ast.from,\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"effect/PropertySignature\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @since 3.10.0\n * @category guards\n */\nexport const isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withConstructorDefault: {\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\nconst pruneUndefined = (ast: AST.AST): AST.AST | undefined =>\n  AST.pruneUndefined(ast, pruneUndefined, (ast) => {\n    const pruned = pruneUndefined(ast.to)\n    if (pruned) {\n      return new AST.Transformation(ast.from, pruned, ast.transformation)\n    }\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDecodingDefault: {\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      const to = AST.typeAST(ast.type)\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations),\n          new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      const to = ast.to.type\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(\n            pruneUndefined(to) ?? to,\n            false,\n            ast.to.isReadonly,\n            ast.to.annotations,\n            ast.to.defaultValue\n          ),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n    }\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDefaults: {\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const fromKey: {\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 3.10.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            self,\n            typeSchema(self),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          self,\n          OptionFromSelf(typeSchema(self)),\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(self),\n          typeSchema(self),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(self),\n          UndefinedOr(typeSchema(self)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optional = <S extends Schema.All>(self: S): optional<S> => {\n  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword\n    ? AST.undefinedKeyword\n    : UndefinedOr(self).ast\n  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalWith: {\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options: Options): (self: S) => optionalWith<S, Options>\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options: Options): optionalWith<S, Options>\n} = dual((args) => isSchema(args[0]), (self, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)\n})\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Struct {\n  /**\n   * Useful for creating a type that can be used to add custom constraints to the fields of a struct.\n   *\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * const f = <Fields extends Record<\"a\" | \"b\", Schema.Struct.Field>>(\n   *   schema: Schema.Struct<Fields>\n   * ) => {\n   *   return schema.omit(\"a\")\n   * }\n   *\n   * //      ┌─── Schema.Struct<{ b: typeof Schema.Number; }>\n   * //      ▼\n   * const result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))\n   * ```\n   * @since 3.13.11\n   */\n  export type Field =\n    | Schema.All\n    | PropertySignature.All\n\n  /**\n   * @since 3.10.0\n   */\n  export type Fields = { readonly [x: PropertyKey]: Field }\n\n  type OptionalEncodedPropertySignature =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown>\n\n  type EncodedOptionalKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalEncodedPropertySignature ? K\n      : never\n  }[keyof Fields]\n\n  type OptionalTypePropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  // type TypeOptionalKeys<Fields extends Struct.Fields> = {\n  //   [K in keyof Fields]: Fields[K] extends OptionalTypePropertySignature ? K : never\n  // }[keyof Fields]\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedOptionalKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedOptionalKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  type MergeTuple<T extends ReadonlyArray<unknown>> = T extends readonly [infer Head, ...infer Tail] ?\n    Head & MergeTuple<Tail>\n    : {}\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Records extends IndexSignature.Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Records extends IndexSignature.Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst preserveMissingMessageAnnotation = AST.pickAnnotations([AST.MissingMessageAnnotationId])\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = util_.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.AutoTitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.AutoTitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = util_.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nfunction makeTypeLiteralClass<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends\n  AnnotableClass<\n    Struct<Fields>,\n    Simplify<Struct.Type<Fields>>,\n    Simplify<Struct.Encoded<Fields>>,\n    Struct.Context<Fields>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: readonly []\n  make(\n    props: RequiredKeys<Struct.Constructor<Fields>> extends never ? void | Simplify<Struct.Constructor<Fields>>\n      : Simplify<Struct.Constructor<Fields>>,\n    options?: MakeOptions\n  ): Simplify<Struct.Type<Fields>>\n\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Schema } from \"effect\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @see {@link TaggedStruct}\n *\n * @since 3.10.0\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Schema } from \"effect\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends\n  AnnotableClass<\n    Record$<K, V>,\n    { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    { readonly [P in Schema.Encoded<K>]: Schema.Encoded<V> },\n    | Schema.Context<K>\n    | Schema.Context<V>\n  >\n{\n  readonly fields: {}\n  readonly records: readonly [{ readonly key: K; readonly value: V }]\n  readonly key: K\n  readonly value: V\n  make(\n    props: void | { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    options?: MakeOptions\n  ): { readonly [P in Schema.Type<K>]: Schema.Type<V> }\n  annotations(annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>): Record$<K, V>\n}\n\nfunction makeRecordClass<K extends Schema.All, V extends Schema.All>(\n  key: K,\n  value: V,\n  ast?: AST.AST\n): Record$<K, V> {\n  return class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n    static override annotations(\n      annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>\n    ): Record$<K, V> {\n      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static key = key\n\n    static value = value\n  }\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(\n  options: { readonly key: K; readonly value: V }\n): Record$<K, V> => makeRecordClass(options.key, options.value)\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = Schema.Struct({\n *   column1: Schema.NumberFromString,\n *   column2: Schema.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n *\n * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n * ```\n *\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pluck: {\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make</**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    A[K], /**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    A[K], /**\n     * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n     * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n     *\n     * @example\n     * ```ts\n     * import * as Schema from \"effect/Schema\"\n     *\n     * // ---------------------------------------------\n     * // use case: pull out a single field from a\n     * // struct through a transformation\n     * // ---------------------------------------------\n     *\n     * const mytable = Schema.Struct({\n     *   column1: Schema.NumberFromString,\n     *   column2: Schema.Number\n     * })\n     *\n     * // const pullOutColumn: S.Schema<number, {\n     * //     readonly column1: string;\n     * // }, never>\n     * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n     *\n     * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n     * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n     * ```\n     *\n     * @category struct transformations\n     * @since 3.10.0\n     */\n    R>(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    const out = transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (i) => i[key],\n        encode: (a) => ps.isOptional && a === undefined ? {} : { [key]: a } as any\n      }\n    )\n    return out\n  }\n)\n\n/**\n * @category branding\n * @since 3.10.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nfunction makeBrandClass<S extends Schema.Any, B extends string | symbol>(\n  from: S,\n  ast: AST.AST\n): brand<S, B> {\n  return class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n\n    static from = from\n  }\n}\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n * ```\n *\n * @category branding\n * @since 3.10.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      [AST.BrandAnnotationId]: annotation,\n      ...annotations\n    })\n  )\n  return makeBrandClass(self, ast)\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partial = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>\n  make(AST.partial(self.ast))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partialWith: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(self: Schema<A, I, R>, options: Options): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.omitAnnotations([AST.IdentifierAnnotationId])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (x: AST.AST, y: AST.AST, path: ReadonlyArray<PropertyKey>): AST.AST =>\n  AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (y._tag) {\n        case \"Literal\": {\n          if (\n            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||\n              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||\n              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))\n          ) {\n            return [y]\n          }\n          break\n        }\n        case \"StringKeyword\": {\n          if (y === AST.stringKeyword) {\n            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.stringKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"NumberKeyword\": {\n          if (y === AST.numberKeyword) {\n            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.numberKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"BooleanKeyword\": {\n          if (y === AST.booleanKeyword) {\n            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.booleanKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"Union\":\n          return intersectUnionMembers(getTypes(x), y.types, path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n        case \"Refinement\":\n          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))\n        case \"TypeLiteral\": {\n          switch (x._tag) {\n            case \"Union\":\n              return intersectUnionMembers(x.types, [y], path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n            case \"Refinement\":\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              const transformation = x.transformation\n              const from = intersectTypeLiterals(x.from, y, path)\n              const to = intersectTypeLiterals(x.to, AST.typeAST(y), path)\n              switch (transformation._tag) {\n                case \"TypeLiteralTransformation\":\n                  return [\n                    new AST.Transformation(\n                      from,\n                      to,\n                      new AST.TypeLiteralTransformation(transformation.propertySignatureTransformations)\n                    )\n                  ]\n                case \"ComposeTransformation\":\n                  return [new AST.Transformation(from, to, AST.composeTransformation)]\n                case \"FinalTransformation\":\n                  return [\n                    new AST.Transformation(\n                      from,\n                      to,\n                      new AST.FinalTransformation(\n                        (fromA, options, ast, fromI) =>\n                          ParseResult.map(\n                            transformation.decode(fromA, options, ast, fromI),\n                            (partial) => ({ ...fromA, ...partial })\n                          ),\n                        (toI, options, ast, toA) =>\n                          ParseResult.map(\n                            transformation.encode(toI, options, ast, toA),\n                            (partial) => ({ ...toI, ...partial })\n                          )\n                      )\n                    )\n                  ]\n              }\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTransformation(x)) {\n            if (\n              AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteralTransformation(x.transformation)\n            ) {\n              return [\n                new AST.Transformation(\n                  intersectTypeLiterals(x.from, y.from, path),\n                  intersectTypeLiterals(x.to, y.to, path),\n                  new AST.TypeLiteralTransformation(\n                    y.transformation.propertySignatureTransformations.concat(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                )\n              ]\n            }\n          } else {\n            return intersectUnionMembers([y], [x], path)\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema with another schema.\n *\n * Not all extensions are supported, and their support depends on the nature of\n * the involved schemas.\n *\n * Possible extensions include:\n * - `Schema.String` with another `Schema.String` refinement or a string literal\n * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n *   literal\n * - A struct with another struct where overlapping fields support extension\n * - A struct with in index signature\n * - A struct with a union of supported schemas\n * - A refinement of a struct with a supported schema\n * - A suspend of a struct with a supported schema\n * - A transformation between structs where the “from” and “to” sides have no\n *   overlapping fields with the target struct\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: Schema<\n * //   {\n * //     readonly a: string\n * //     readonly b: string\n * //   } & {\n * //     readonly c: string\n * //   } & {\n * //     readonly [x: string]: string\n * //   }\n * // >\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n * ))\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const extend: {\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of\n   * the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n   *   literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   * - A transformation between structs where the “from” and “to” sides have no\n   *   overlapping fields with the target struct\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of\n   * the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n   *   literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   * - A transformation between structs where the “from” and “to” sides have no\n   *   overlapping fields with the target struct\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const compose: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, C extends Schema.Type<From>>(to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): (from: From) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To): <From extends Schema.Any, B extends Schema.Encoded<To>>(\n    from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>\n  ) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To, options?: { readonly strict: true }): <From extends Schema.Any>(\n    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>\n  ) => transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <To extends Schema.Any>(to: To, options: { readonly strict: false }): <From extends Schema.Any>(from: From) => transform<From, To>\n\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any, C extends Schema.Type<From>>(from: From, to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, B extends Schema.Encoded<To>, To extends Schema.Any>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>, to: To): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any>(\n    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>,\n    to: To,\n    options?: { readonly strict: true }\n  ): transform<From, To>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <From extends Schema.Any, To extends Schema.Any>(from: From, to: To, options: { readonly strict: false }): transform<From, To>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    makeTransformationClass(from, to, AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const RefineSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Refine\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type RefineSchemaId = typeof RefineSchemaId\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  /** The following is required for {@link HasFields} to work */\n  readonly [RefineSchemaId]: From\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nfunction makeRefineClass<From extends Schema.Any, A>(\n  from: From,\n  filter: (a: Schema.Type<From>, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> {\n  return class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n    static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static [RefineSchemaId] = from\n\n    static from = from\n\n    static filter = filter\n\n    static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 3.10.0\n */\nexport const filterEffect: {\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (i, options, ast) =>\n        ParseResult.flatMap(\n          f(i, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, i), {\n              onNone: () => ParseResult.succeed(i),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: (a) => ParseResult.succeed(a)\n    }\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformOrFail<From extends Schema.All, To extends Schema.All, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nfunction makeTransformationClass<From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<From, To, R> {\n  return class TransformationClass\n    extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n  {\n    static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n      return makeTransformationClass<From, To, R>(\n        this.from,\n        this.to,\n        mergeSchemaAnnotations(this.ast, annotations)\n      )\n    }\n\n    static from = from\n\n    static to = to\n  }\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transformOrFail: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      fromI: FromI\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      toA: ToA\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transform<From extends Schema.All, To extends Schema.All> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transform: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA, fromI: FromI) => ToI\n      readonly encode: (toI: ToI, toA: ToA) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),\n        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformLiteral<Type extends AST.LiteralValue, Encoded extends AST.LiteralValue>\n  extends transform<Literal<[Encoded]>, Literal<[Type]>>\n{\n  annotations(annotations: Annotations.Schema<Type>): transformLiteral<Type, Encoded>\n}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiteral<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> {\n  return transform(Literal(from), Literal(to), {\n    strict: true,\n    decode: () => to,\n    encode: () => from\n  })\n}\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as S from \"effect/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const attachPropertySignature: {\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: SchemaClass<A, I, R>\n  ) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 3.10.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }\n\n  /**\n   * @since 3.11.6\n   */\n  export interface GenericSchema<A> extends Schema<A> {\n    readonly arbitrary?: (..._: any) => LazyArbitrary<A>\n    readonly pretty?: (..._: any) => pretty_.Pretty<A>\n    readonly equivalence?: (..._: any) => Equivalence.Equivalence<A>\n  }\n\n  // TODO(4.0): replace `readonly [P]` with `readonly []`\n  /**\n   * @since 3.10.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * Merges a set of new annotations with existing ones, potentially overwriting\n * any duplicates.\n *\n * @category annotations\n * @since 3.10.0\n */\nexport const annotations: {\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.GenericSchema<A>): Schema<A, I, R> =>\n    self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 3.10.0\n */\nexport const rename: {\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const TrimmedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const trimmed = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a === a.trim(), {\n      schemaId: TrimmedSchemaId,\n      title: \"trimmed\",\n      description: \"a string with no leading or trailing whitespace\",\n      jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxLengthSchemaId: unique symbol = schemaId_.MaxLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxLengthSchemaId = typeof MaxLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const maxLength =\n  <S extends Schema.Any>(maxLength: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter(\n        (a) => a.length <= maxLength,\n        {\n          schemaId: MaxLengthSchemaId,\n          title: `maxLength(${maxLength})`,\n          description: `a string at most ${maxLength} character(s) long`,\n          jsonSchema: { maxLength },\n          ...annotations\n        }\n      )\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinLengthSchemaId: unique symbol = schemaId_.MinLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinLengthSchemaId = typeof MinLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const minLength = <S extends Schema.Any>(\n  minLength: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        schemaId: MinLengthSchemaId,\n        title: `minLength(${minLength})`,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LengthSchemaId: unique symbol = schemaId_.LengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LengthSchemaId = typeof LengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const length = <S extends Schema.Any>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        schemaId: LengthSchemaId,\n        title: `length({ min: ${minLength}, max: ${maxLength})`,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      schemaId: LengthSchemaId,\n      title: `length(${minLength})`,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PatternSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Pattern\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const pattern = <S extends Schema.Any>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const source = regex.source\n  return self.pipe(\n    filter(\n      (a) => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        schemaId: PatternSchemaId,\n        [PatternSchemaId]: { regex },\n        // title: `pattern(/${source}/)`, // avoiding this because it can be very long\n        description: `a string matching the pattern ${source}`,\n        jsonSchema: { pattern: source },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const StartsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/StartsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const startsWith = <S extends Schema.Any>(\n  startsWith: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(startsWith)\n  return self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        schemaId: StartsWithSchemaId,\n        [StartsWithSchemaId]: { startsWith },\n        title: `startsWith(${formatted})`,\n        description: `a string starting with ${formatted}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const EndsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/EndsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const endsWith = <S extends Schema.Any>(\n  endsWith: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(endsWith)\n  return self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        schemaId: EndsWithSchemaId,\n        [EndsWithSchemaId]: { endsWith },\n        title: `endsWith(${formatted})`,\n        description: `a string ending with ${formatted}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IncludesSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Includes\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const includes = <S extends Schema.Any>(\n  searchString: string,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formatted = JSON.stringify(searchString)\n  return self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        schemaId: IncludesSchemaId,\n        [IncludesSchemaId]: { includes: searchString },\n        title: `includes(${formatted})`,\n        description: `a string including ${formatted}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LowercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const lowercased =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        schemaId: LowercasedSchemaId,\n        title: \"lowercased\",\n        description: \"a lowercase string\",\n        jsonSchema: { pattern: \"^[^A-Z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UppercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uppercased =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        schemaId: UppercasedSchemaId,\n        title: \"uppercased\",\n        description: \"an uppercase string\",\n        jsonSchema: { pattern: \"^[^a-z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const CapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const capitalized =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        schemaId: CapitalizedSchemaId,\n        title: \"capitalized\",\n        description: \"a capitalized string\",\n        jsonSchema: { pattern: \"^[^a-z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UncapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uncapitalized =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        schemaId: UncapitalizedSchemaId,\n        title: \"uncapitalized\",\n        description: \"a uncapitalized string\",\n        jsonSchema: { pattern: \"^[^A-Z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\" })\n) {}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const nonEmptyString = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  minLength(1, {\n    title: \"nonEmptyString\",\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Lowercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to lowercase\" }),\n  Lowercased,\n  {\n    strict: true,\n    decode: (i) => i.toLowerCase(),\n    encode: identity\n  }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uppercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to uppercase\" }),\n  Uppercased,\n  {\n    strict: true,\n    decode: (i) => i.toUpperCase(),\n    encode: identity\n  }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Capitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to a capitalized format\" }),\n  Capitalized,\n  {\n    strict: true,\n    decode: (i) => string_.capitalize(i),\n    encode: identity\n  }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uncapitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to an uncapitalized format\" }),\n  Uncapitalized,\n  {\n    strict: true,\n    decode: (i) => string_.uncapitalize(i),\n    encode: identity\n  }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\" })\n) {}\n\n/**\n * Useful for validating strings that must contain meaningful characters without\n * leading or trailing whitespace.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyTrimmedString extends Trimmed.pipe(\n  nonEmptyString({ identifier: \"NonEmptyTrimmedString\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Trim extends transform(\n  String$.annotations({ description: \"a string that will be trimmed\" }),\n  Trimmed,\n  {\n    strict: true,\n    decode: (i) => i.trim(),\n    encode: identity\n  }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const split = (separator: string): transform<SchemaClass<string>, Array$<typeof String$>> =>\n  transform(\n    String$.annotations({ description: \"a string that will be split\" }),\n    Array$(String$),\n    {\n      strict: true,\n      decode: (i) => i.split(separator),\n      encode: (a) => a.join(separator)\n    }\n  )\n\n/**\n * @since 3.10.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst getErrorMessage = (e: unknown): string => e instanceof Error ? e.message : String(e)\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions): SchemaClass<unknown, string> =>\n  transformOrFail(\n    String$.annotations({ description: \"a string to be decoded into JSON\" }),\n    Unknown,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(i, options?.reviver),\n          catch: (e) => new ParseResult.Type(ast, i, getErrorMessage(e))\n        }),\n      encode: (a, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(a, options?.replacer, options?.space),\n          catch: (e) => new ParseResult.Type(ast, a, getErrorMessage(e))\n        })\n    }\n  ).annotations({\n    title: \"parseJson\",\n    schemaId: AST.ParseJsonSchemaId\n  })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as Schema from \"effect/Schema\"\n *\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n * ```\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const parseJson: {\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schemaOrOptions)\n    ? compose(parseJson(o), schemaOrOptions) as any\n    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyString extends String$.pipe(\n  nonEmptyString({ identifier: \"NonEmptyString\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UUIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    schemaId: UUIDSchemaId,\n    identifier: \"UUID\",\n    jsonSchema: {\n      format: \"uuid\",\n      pattern: uuidRegexp.source\n    },\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ULIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    schemaId: ULIDSchemaId,\n    identifier: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * Defines a schema that represents a `URL` object.\n *\n * @category URL constructors\n * @since 3.11.0\n */\nexport class URLFromSelf extends instanceOf(URL, {\n  identifier: \"URLFromSelf\",\n  arbitrary: (): LazyArbitrary<URL> => (fc) => fc.webUrl().map((s) => new URL(s)),\n  pretty: () => (url) => url.toString()\n}) {}\n\n/** @ignore */\nclass URL$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a URL\" }),\n  URLFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.try({\n        try: () => new URL(i),\n        catch: (e) =>\n          new ParseResult.Type(\n            ast,\n            i,\n            `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage(e)}`\n          )\n      }),\n    encode: (a) => ParseResult.succeed(a.toString())\n  }\n).annotations({\n  identifier: \"URL\",\n  pretty: () => (url) => url.toString()\n}) {}\n\nexport {\n  /**\n   * Defines a schema that attempts to convert a `string` to a `URL` object using\n   * the `new URL` constructor.\n   *\n   * @category URL transformations\n   * @since 3.11.0\n   */\n  URL$ as URL\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const FiniteSchemaId: unique symbol = schemaId_.FiniteSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type FiniteSchemaId = typeof FiniteSchemaId\n\n/**\n * Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const finite =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter(Number.isFinite, {\n        schemaId: FiniteSchemaId,\n        title: \"finite\",\n        description: \"a finite number\",\n        jsonSchema: { \"type\": \"number\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanSchemaId: unique symbol = schemaId_.GreaterThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanSchemaId = typeof GreaterThanSchemaId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThan = <S extends Schema.Any>(\n  exclusiveMinimum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a > exclusiveMinimum, {\n      schemaId: GreaterThanSchemaId,\n      title: `greaterThan(${exclusiveMinimum})`,\n      description: exclusiveMinimum === 0 ? \"a positive number\" : `a number greater than ${exclusiveMinimum}`,\n      jsonSchema: { exclusiveMinimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualTo = <S extends Schema.Any>(\n  minimum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= minimum, {\n      schemaId: GreaterThanOrEqualToSchemaId,\n      title: `greaterThanOrEqualTo(${minimum})`,\n      description: minimum === 0 ? \"a non-negative number\" : `a number greater than or equal to ${minimum}`,\n      jsonSchema: { minimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MultipleOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const multipleOf = <S extends Schema.Any>(\n  divisor: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const positiveDivisor = Math.abs(divisor) // spec requires positive divisor\n  return self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      schemaId: MultipleOfSchemaId,\n      title: `multipleOf(${positiveDivisor})`,\n      description: `a number divisible by ${positiveDivisor}`,\n      jsonSchema: { multipleOf: positiveDivisor },\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IntSchemaId: unique symbol = schemaId_.IntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type IntSchemaId = typeof IntSchemaId\n\n/**\n * Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const int =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        schemaId: IntSchemaId,\n        title: \"int\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanSchemaId: unique symbol = schemaId_.LessThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanSchemaId = typeof LessThanSchemaId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThan =\n  <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a < exclusiveMaximum, {\n        schemaId: LessThanSchemaId,\n        title: `lessThan(${exclusiveMaximum})`,\n        description: exclusiveMaximum === 0 ? \"a negative number\" : `a number less than ${exclusiveMaximum}`,\n        jsonSchema: { exclusiveMaximum },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToSchemaId: unique symbol = schemaId_.LessThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualTo = <S extends Schema.Any>(\n  maximum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a <= maximum, {\n      schemaId: LessThanOrEqualToSchemaId,\n      title: `lessThanOrEqualTo(${maximum})`,\n      description: maximum === 0 ? \"a non-positive number\" : `a number less than or equal to ${maximum}`,\n      jsonSchema: { maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenSchemaId: unique symbol = schemaId_.BetweenSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenSchemaId = typeof BetweenSchemaId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const between = <S extends Schema.Any>(\n  minimum: number,\n  maximum: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= minimum && a <= maximum, {\n      schemaId: BetweenSchemaId,\n      title: `between(${minimum}, ${maximum})`,\n      description: `a number between ${minimum} and ${maximum}`,\n      jsonSchema: { minimum, maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNaNSchemaId: unique symbol = schemaId_.NonNaNSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type NonNaNSchemaId = typeof NonNaNSchemaId\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNaN =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        schemaId: NonNaNSchemaId,\n        title: \"nonNaN\",\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const positive = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThan(0, { title: \"positive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const negative = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThan(0, { title: \"negative\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonPositive = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanOrEqualTo(0, { title: \"nonPositive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNegative = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanOrEqualTo(0, { title: \"nonNegative\", ...annotations })\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const clamp = (minimum: number, maximum: number) =>\n<S extends Schema.Any, A extends number>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, filter<SchemaClass<A>>> => {\n  return transform(\n    self,\n    typeSchema(self).pipe(between(minimum, maximum)),\n    {\n      strict: false,\n      decode: (i) => number_.clamp(i, { minimum, maximum }),\n      encode: identity\n    }\n  )\n}\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse`\n * function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when\n * non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\",\n * \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport function parseNumber<S extends Schema.Any, A extends string>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transformOrFail<S, typeof Number$> {\n  return transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (i, _, ast) =>\n        ParseResult.fromOption(\n          number_.parse(i),\n          () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)\n        ),\n      encode: (a) => ParseResult.succeed(String(a))\n    }\n  )\n}\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport class NumberFromString extends parseNumber(String$.annotations({\n  description: \"a string to be decoded into a number\"\n})).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const JsonNumberSchemaId: unique symbol = schemaId_.JsonNumberSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type JsonNumberSchemaId = typeof JsonNumberSchemaId\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import * as Schema from \"effect/Schema\"\n *\n * const is = Schema.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n * ```\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class JsonNumber extends Number$.pipe(\n  finite({\n    schemaId: JsonNumberSchemaId,\n    identifier: \"JsonNumber\"\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 3.10.0\n */\nexport class Not extends transform(Boolean$.annotations({ description: \"a boolean that will be negated\" }), Boolean$, {\n  strict: true,\n  decode: (i) => boolean_.not(i),\n  encode: (a) => boolean_.not(a)\n}) {}\n\nconst encodeSymbol = (sym: symbol, ast: AST.AST) => {\n  const key = Symbol.keyFor(sym)\n  return key === undefined\n    ? ParseResult.fail(\n      new ParseResult.Type(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)\n    )\n    : ParseResult.succeed(key)\n}\n\nconst decodeSymbol = (s: string) => ParseResult.succeed(Symbol.for(s))\n\n/** @ignore */\nclass Symbol$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a globally shared symbol\" }),\n  SymbolFromSelf,\n  {\n    strict: false,\n    decode: (i) => decodeSymbol(i),\n    encode: (a, _, ast) => encodeSymbol(a, ast)\n  }\n).annotations({ identifier: \"Symbol\" }) {}\n\nexport {\n  /**\n   * Converts a string key into a globally shared symbol.\n   *\n   * @category symbol transformations\n   * @since 3.10.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigIntSchemaId: unique symbol = schemaId_.GreaterThanBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanBigInt = <S extends Schema.Any>(\n  min: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanBigIntSchemaId,\n      [GreaterThanBigIntSchemaId]: { min },\n      title: `greaterThanBigInt(${min})`,\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigInt = <S extends Schema.Any>(\n  min: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToBigIntSchemaId,\n      [GreaterThanOrEqualToBigIntSchemaId]: { min },\n      title: `greaterThanOrEqualToBigInt(${min})`,\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigIntSchemaId: unique symbol = schemaId_.LessThanBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanBigInt = <S extends Schema.Any>(\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanBigIntSchemaId,\n      [LessThanBigIntSchemaId]: { max },\n      title: `lessThanBigInt(${max})`,\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigInt = <S extends Schema.Any>(\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToBigIntSchemaId,\n      [LessThanOrEqualToBigIntSchemaId]: { max },\n      title: `lessThanOrEqualToBigInt(${max})`,\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigIntSchemaId: unique symbol = schemaId_.BetweenBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const betweenBigInt = <S extends Schema.Any>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenBigIntSchemaId,\n      [BetweenBigIntSchemaId]: { min, max },\n      title: `betweenBigInt(${min}, ${max})`,\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const positiveBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanBigInt(0n, { title: \"positiveBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const negativeBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanBigInt(0n, { title: \"negativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonNegativeBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  greaterThanOrEqualToBigInt(0n, { title: \"nonNegativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonPositiveBigInt = <S extends Schema.Any>(\n  annotations?: Annotations.Filter<Schema.Type<S>>\n): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>\n  lessThanOrEqualToBigInt(0n, { title: \"nonPositiveBigInt\", ...annotations })\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport const clampBigInt = (minimum: bigint, maximum: bigint) =>\n<S extends Schema.Any, A extends bigint>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, filter<SchemaClass<A>>> =>\n  transform(\n    self,\n    self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n    {\n      strict: false,\n      decode: (i) => bigInt_.clamp(i, { minimum, maximum }),\n      encode: identity\n    }\n  )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromString(i),\n        () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)\n      ),\n    encode: (a) => ParseResult.succeed(String(a))\n  }\n).annotations({ identifier: \"BigInt\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 3.10.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number to be decoded into a bigint\" }),\n  BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))),\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(i),\n        () => new ParseResult.Type(ast, i, `Unable to decode ${i} into a bigint`)\n      ),\n    encode: (a, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.toNumber(a),\n        () => new ParseResult.Type(ast, a, `Unable to encode ${a}n into a number`)\n      )\n  }\n).annotations({ identifier: \"BigIntFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map(redacted_.make)\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 3.10.0\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(value: Value): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Redacted<Value extends Schema.Any>\n  extends transform<Value, RedactedFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * A transformation that transform a `Schema<A, I, R>` into a\n * `RedactedFromSelf<A>`.\n *\n * @category Redacted transformations\n * @since 3.10.0\n */\nexport function Redacted<Value extends Schema.Any>(value: Value): Redacted<Value> {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => redacted_.make(i),\n      encode: (a) => redacted_.value(a)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 3.10.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigInt({ min: 0n }).map((_) => duration_.nanos(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a non negative `bigint` into a `Duration`. Treats\n * the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  NonNegativeBigIntFromSelf.annotations({ description: \"a bigint to be decoded into a Duration\" }),\n  DurationFromSelf.pipe(filter((duration) => duration_.isFinite(duration), { description: \"a finite duration\" })),\n  {\n    strict: true,\n    decode: (i) => ParseResult.succeed(duration_.nanos(i)),\n    encode: (a, _, ast) =>\n      option_.match(duration_.toNanos(a), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, a, `Unable to encode ${a} into a bigint`)),\n        onSome: (nanos) => ParseResult.succeed(nanos)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A non-negative integer. +Infinity is excluded.\n *\n * @category number constructors\n * @since 3.11.10\n */\nexport const NonNegativeInt = NonNegative.pipe(int()).annotations({ identifier: \"NonNegativeInt\" })\n\n/**\n * A schema that transforms a (possibly Infinite) non negative number into a\n * `Duration`. Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromMillis extends transform(\n  NonNegative.annotations({\n    description: \"a non-negative number to be decoded into a Duration\"\n  }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (i) => duration_.millis(i),\n    encode: (a) => duration_.toMillis(a)\n  }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\nconst DurationValueMillis = TaggedStruct(\"Millis\", { millis: NonNegativeInt })\nconst DurationValueNanos = TaggedStruct(\"Nanos\", { nanos: BigInt$ })\nconst DurationValueInfinity = TaggedStruct(\"Infinity\", {})\nconst durationValueInfinity = DurationValueInfinity.make({})\n\n/**\n * @category Duration utils\n * @since 3.12.8\n */\nexport type DurationEncoded =\n  | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: string\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }\n\nconst DurationValue: Schema<duration_.DurationValue, DurationEncoded> = Union(\n  DurationValueMillis,\n  DurationValueNanos,\n  DurationValueInfinity\n).annotations({\n  identifier: \"DurationValue\",\n  description: \"an JSON-compatible tagged union to be decoded into a Duration\"\n})\n\nconst FiniteHRTime = Tuple(\n  element(NonNegativeInt).annotations({ title: \"seconds\" }),\n  element(NonNegativeInt).annotations({ title: \"nanos\" })\n).annotations({ identifier: \"FiniteHRTime\" })\n\nconst InfiniteHRTime = Tuple(Literal(-1), Literal(0)).annotations({ identifier: \"InfiniteHRTime\" })\n\nconst HRTime: Schema<readonly [seconds: number, nanos: number]> = Union(FiniteHRTime, InfiniteHRTime).annotations({\n  identifier: \"HRTime\",\n  description: \"a tuple of seconds and nanos to be decoded into a Duration\"\n})\n\nconst isDurationValue = (u: duration_.DurationValue | typeof HRTime.Type): u is duration_.DurationValue =>\n  typeof u === \"object\"\n\n// TODO(4.0): remove HRTime union member\n/**\n * A schema that converts a JSON-compatible tagged union into a `Duration`.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class Duration extends transform(\n  Union(DurationValue, HRTime),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (i) => {\n      if (isDurationValue(i)) {\n        switch (i._tag) {\n          case \"Millis\":\n            return duration_.millis(i.millis)\n          case \"Nanos\":\n            return duration_.nanos(i.nanos)\n          case \"Infinity\":\n            return duration_.infinity\n        }\n      }\n      const [seconds, nanos] = i\n      return seconds === -1 ? duration_.infinity : duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos))\n    },\n    encode: (a) => {\n      switch (a.value._tag) {\n        case \"Millis\":\n          return DurationValueMillis.make({ millis: a.value.millis })\n        case \"Nanos\":\n          return DurationValueNanos.make({ nanos: a.value.nanos })\n        case \"Infinity\":\n          return durationValueInfinity\n      }\n    }\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <S extends Schema.Any, A extends duration_.Duration>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ): transform<S, filter<SchemaClass<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      {\n        strict: false,\n        decode: (i) => duration_.clamp(i, { minimum, maximum }),\n        encode: identity\n      }\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanDuration = <S extends Schema.Any>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanDuration(${max})`,\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDuration = <S extends Schema.Any>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanOrEqualToDuration(${max})`,\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanDuration = <S extends Schema.Any>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      schemaId: GreaterThanDurationSchemaId,\n      [GreaterThanDurationSchemaId]: { min },\n      title: `greaterThanDuration(${min})`,\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDuration = <S extends Schema.Any>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToDurationSchemaId,\n      [GreaterThanOrEqualToDurationSchemaId]: { min },\n      title: `greaterThanOrEqualToDuration(${min})`,\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const betweenDuration = <S extends Schema.Any>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      schemaId: BetweenDurationSchemaId,\n      [BetweenDurationSchemaId]: { maximum, minimum },\n      title: `betweenDuration(${minimum}, ${maximum})`,\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 3.10.0\n */\nexport class Uint8ArrayFromSelf extends declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n) {}\n\n/**\n * @category number constructors\n * @since 3.11.10\n */\nexport class Uint8 extends Number$.pipe(\n  between(0, 255, {\n    identifier: \"Uint8\",\n    description: \"a 8-bit unsigned integer\"\n  })\n) {}\n\n/** @ignore */\nclass Uint8Array$ extends transform(\n  Array$(Uint8).annotations({\n    description: \"an array of 8-bit unsigned integers to be decoded into a Uint8Array\"\n  }),\n  Uint8ArrayFromSelf,\n  {\n    strict: true,\n    decode: (i) => Uint8Array.from(i),\n    encode: (a) => Array.from(a)\n  }\n).annotations({ identifier: \"Uint8Array\" }) {}\n\nexport {\n  /**\n   * A schema that transforms an array of numbers into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 3.10.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeUint8ArrayTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n) =>\n  transformOrFail(\n    String$.annotations({ description: \"a string to be decoded into a Uint8Array\" }),\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        either_.mapLeft(\n          decode(i),\n          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n        ),\n      encode: (a) => ParseResult.succeed(encode(a))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromHex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,\n  encode: (u: string) => string\n) =>\n  transformOrFail(\n    String$.annotations({\n      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`\n    }),\n    String$,\n    {\n      strict: true,\n      decode: (i, _, ast) =>\n        either_.mapLeft(\n          decode(i),\n          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n        ),\n      encode: (a) => ParseResult.succeed(encode(a))\n    }\n  ).annotations({ identifier: `StringFrom${id}` })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64: Schema<string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64String,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64Url: Schema<string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64UrlString,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromHex: Schema<string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHexString,\n  Encoding.encodeHex\n)\n\n/**\n * Decodes a URI component encoded string into a UTF-8 string.\n * Can be used to store data in a URL.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const PaginationSchema = Schema.Struct({\n *   maxItemPerPage: Schema.Number,\n *   page: Schema.Number\n * })\n *\n * const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n *\n * console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n * // Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D\n * ```\n *\n * @category string transformations\n * @since 3.12.0\n */\nexport const StringFromUriComponent = transformOrFail(\n  String$.annotations({\n    description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`\n  }),\n  String$,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      either_.mapLeft(\n        Encoding.decodeUriComponent(i),\n        (decodeException) => new ParseResult.Type(ast, i, decodeException.message)\n      ),\n    encode: (a, _, ast) =>\n      either_.mapLeft(\n        Encoding.encodeUriComponent(a),\n        (encodeException) => new ParseResult.Type(ast, a, encodeException.message)\n      )\n  }\n).annotations({ identifier: `StringFromUriComponent` })\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinItemsSchemaId: unique symbol = schemaId_.MinItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinItemsSchemaId = typeof MinItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const minItems = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        schemaId: MinItemsSchemaId,\n        title: `minItems(${minItems})`,\n        description: `an array of at least ${minItems} item(s)`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxItemsSchemaId: unique symbol = schemaId_.MaxItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxItemsSchemaId = typeof MaxItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const maxItems = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const maxItems = Math.floor(n)\n  if (maxItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length <= maxItems, {\n      schemaId: MaxItemsSchemaId,\n      title: `maxItems(${maxItems})`,\n      description: `an array of at most ${maxItems} item(s)`,\n      jsonSchema: { maxItems },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ItemsCountSchemaId: unique symbol = schemaId_.ItemsCountSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type ItemsCountSchemaId = typeof ItemsCountSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const itemsCount = <S extends Schema.Any>(\n  n: number,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const itemsCount = Math.floor(n)\n  if (itemsCount < 0) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === itemsCount, {\n      schemaId: ItemsCountSchemaId,\n      title: `itemsCount(${itemsCount})`,\n      description: `an array of exactly ${itemsCount} item(s)`,\n      jsonSchema: { minItems: itemsCount, maxItems: itemsCount },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport function head<S extends Schema.Any, A extends ReadonlyArray<unknown>>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, OptionFromSelf<SchemaClass<A[number]>>> {\n  return transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    {\n      strict: false,\n      decode: (i) => array_.head(i),\n      encode: (a) =>\n        option_.match(a, {\n          onNone: () => [],\n          onSome: array_.of\n        })\n    }\n  )\n}\n\n/**\n * Get the first element of a `NonEmptyReadonlyArray`.\n *\n * @category NonEmptyReadonlyArray transformations\n * @since 3.12.0\n */\nexport function headNonEmpty<S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(\n  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n): transform<S, SchemaClass<A[number]>> {\n  return transform(\n    self,\n    getNumberIndexedAccess(typeSchema(self)),\n    {\n      strict: false,\n      decode: (i) => array_.headNonEmpty(i),\n      encode: (a) => array_.of(a)\n    }\n  )\n}\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const headOrElse: {\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ) => transform<S, SchemaClass<A[number]>>\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>,\n    fallback?: LazyArg<A[number]>\n  ): transform<S, SchemaClass<A[number]>>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(\n    self: Schema<ReadonlyArray<A>, I, R>,\n    fallback?: LazyArg<A>\n  ): transform<Schema<ReadonlyArray<A>, I, R>, SchemaClass<A>> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (i, _, ast) =>\n          i.length > 0\n            ? ParseResult.succeed(i[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, i, \"Unable to retrieve the first element of an empty array\")),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ValidDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 3.10.0\n */\nexport const validDate =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        schemaId: ValidDateSchemaId,\n        [ValidDateSchemaId]: { noInvalidDate: true },\n        title: \"validDate\",\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanDate = <S extends Schema.Any>(\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a < max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      title: `lessThanDate(${util_.formatDate(max)})`,\n      description: `a date before ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDate = <S extends Schema.Any>(\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a <= max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      title: `lessThanOrEqualToDate(${util_.formatDate(max)})`,\n      description: `a date before or equal to ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanDate = <S extends Schema.Any>(\n  min: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a > min, {\n      schemaId: GreaterThanDateSchemaId,\n      [GreaterThanDateSchemaId]: { min },\n      title: `greaterThanDate(${util_.formatDate(min)})`,\n      description: `a date after ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDate = <S extends Schema.Any>(\n  min: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a >= min, {\n      schemaId: GreaterThanOrEqualToDateSchemaId,\n      [GreaterThanOrEqualToDateSchemaId]: { min },\n      title: `greaterThanOrEqualToDate(${util_.formatDate(min)})`,\n      description: `a date after or equal to ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const betweenDate = <S extends Schema.Any>(\n  min: Date,\n  max: Date,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n  self.pipe(\n    filter((a: Date) => a <= max && a >= min, {\n      schemaId: BetweenDateSchemaId,\n      [BetweenDateSchemaId]: { max, min },\n      title: `betweenDate(${util_.formatDate(min)}, ${util_.formatDate(max)})`,\n      description: `a date between ${util_.formatDate(min)} and ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport const DateFromSelfSchemaId: unique symbol = schemaId_.DateFromSelfSchemaId\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport type DateFromSelfSchemaId = typeof DateFromSelfSchemaId\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    schemaId: DateFromSelfSchemaId,\n    [DateFromSelfSchemaId]: { noInvalidDate: false },\n    description: \"a potentially invalid Date instance\",\n    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: () => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromString extends transform(\n  String$.annotations({ description: \"a string to be decoded into a Date\" }),\n  DateFromSelf,\n  {\n    strict: true,\n    decode: (i) => new Date(i),\n    encode: (a) => util_.formatDate(a)\n  }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 3.10.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromNumber extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a Date\" }),\n  DateFromSelf,\n  {\n    strict: true,\n    decode: (i) => new Date(i),\n    encode: (a) => a.getTime()\n  }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * Describes a schema that represents a `DateTime.Utc` instance.\n *\n * @category DateTime.Utc constructors\n * @since 3.10.0\n */\nexport class DateTimeUtcFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),\n  {\n    identifier: \"DateTimeUtcFromSelf\",\n    description: \"a DateTime.Utc instance\",\n    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) =>\n      fc.date({ noInvalidDate: true }).map((date) => dateTime.unsafeFromDate(date)),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\nconst decodeDateTimeUtc = <A extends dateTime.DateTime.Input>(input: A, ast: AST.AST) =>\n  ParseResult.try({\n    try: () => dateTime.unsafeMake(input),\n    catch: () => new ParseResult.Type(ast, input, `Unable to decode ${util_.formatUnknown(input)} into a DateTime.Utc`)\n  })\n\n/**\n * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtcFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.toEpochMillis(a))\n  }\n).annotations({ identifier: \"DateTimeUtcFromNumber\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.12.0\n */\nexport class DateTimeUtcFromDate extends transformOrFail(\n  DateFromSelf.annotations({ description: \"a Date to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.toDateUtc(a))\n  }\n).annotations({ identifier: \"DateTimeUtcFromDate\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtc extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),\n    encode: (a) => ParseResult.succeed(dateTime.formatIso(a))\n  }\n).annotations({ identifier: \"DateTimeUtc\" }) {}\n\nconst timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>\n  fc.integer({ min: -12 * 60 * 60 * 1000, max: 14 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)\n\n/**\n * Describes a schema that represents a `TimeZone.Offset` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneOffsetFromSelf extends declare(\n  dateTime.isTimeZoneOffset,\n  {\n    identifier: \"TimeZoneOffsetFromSelf\",\n    description: \"a TimeZone.Offset instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),\n    arbitrary: timeZoneOffsetArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneOffset extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a TimeZone.Offset\" }),\n  TimeZoneOffsetFromSelf,\n  {\n    strict: true,\n    decode: (i) => dateTime.zoneMakeOffset(i),\n    encode: (a) => a.offset\n  }\n).annotations({ identifier: \"TimeZoneOffset\" }) {}\n\nconst timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>\n  fc.constantFrom(...Intl.supportedValuesOf(\"timeZone\")).map(dateTime.zoneUnsafeMakeNamed)\n\n/**\n * Describes a schema that represents a `TimeZone.Named` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneNamedFromSelf extends declare(\n  dateTime.isTimeZoneNamed,\n  {\n    identifier: \"TimeZoneNamedFromSelf\",\n    description: \"a TimeZone.Named instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),\n    arbitrary: timeZoneNamedArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneNamed extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a TimeZone.Named\" }),\n  TimeZoneNamedFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      ParseResult.try({\n        try: () => dateTime.zoneUnsafeMakeNamed(i),\n        catch: () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)\n      }),\n    encode: (a) => ParseResult.succeed(a.id)\n  }\n).annotations({ identifier: \"TimeZoneNamed\" }) {}\n\n/**\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneFromSelf extends Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZone extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a TimeZone\" }),\n  TimeZoneFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      option_.match(dateTime.zoneFromString(i), {\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (a) => ParseResult.succeed(dateTime.zoneToString(a))\n  }\n).annotations({ identifier: \"TimeZone\" }) {}\n\nconst timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>\n  fc.oneof(\n    timeZoneOffsetArbitrary()(fc),\n    timeZoneNamedArbitrary()(fc)\n  )\n\n/**\n * Describes a schema that represents a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned constructors\n * @since 3.10.0\n */\nexport class DateTimeZonedFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),\n  {\n    identifier: \"DateTimeZonedFromSelf\",\n    description: \"a DateTime.Zoned instance\",\n    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>\n      fc.tuple(\n        fc.integer({\n          // time zone db supports +/- 1000 years or so\n          min: -31536000000000,\n          max: 31536000000000\n        }),\n        timeZoneArbitrary(fc)\n      ).map(([millis, timeZone]) => dateTime.unsafeMakeZoned(millis, { timeZone })),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned transformations\n * @since 3.10.0\n */\nexport class DateTimeZoned extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a DateTime.Zoned\" }),\n  DateTimeZonedFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      option_.match(dateTime.makeZonedFromString(i), {\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (a) => ParseResult.succeed(dateTime.formatIsoZoned(a))\n  }\n).annotations({ identifier: \"DateTimeZoned\" }) {}\n\n/**\n * @category Option utils\n * @since 3.10.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <Value extends Schema.Any>(value: Value) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <Value extends Schema.Any>(value: Value) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary =\n  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>\n    fc.oneof(\n      ctx,\n      fc.record({ _tag: fc.constant(\"None\" as const) }),\n      fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n    ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(value: Value): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  transform<\n    Union<[\n      Struct<{ _tag: Literal<[\"None\"]> }>,\n      Struct<{ _tag: Literal<[\"Some\"]>; value: Value }>\n    ]>,\n    OptionFromSelf<SchemaClass<Schema.Type<Value>>>\n  >\n{}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\n\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function Option<Value extends Schema.Any>(value: Value): Option<Value> {\n  const value_ = asSchema(value)\n  const out = transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (i) => optionDecode(i),\n      encode: (a) =>\n        option_.match(a, {\n          onNone: () => makeNoneEncoded,\n          onSome: makeSomeEncoded\n        })\n    }\n  )\n  return out as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any>\n  extends transform<NullOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromNullOr<Value extends Schema.Any>(value: Value): OptionFromNullOr<Value> {\n  return transform(NullOr(value), OptionFromSelf(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => option_.fromNullable(i),\n    encode: (a) => option_.getOrNull(a)\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any>\n  extends transform<NullishOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromNullishOr<Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> {\n  return transform(\n    NullishOr(value),\n    OptionFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => option_.fromNullable(i),\n      encode: onNoneEncoding === null ?\n        (a) => option_.getOrNull(a) :\n        (a) => option_.getOrUndefined(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any>\n  extends transform<UndefinedOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport function OptionFromUndefinedOr<Value extends Schema.Any>(value: Value): OptionFromUndefinedOr<Value> {\n  return transform(UndefinedOr(value), OptionFromSelf(typeSchema(asSchema(value))), {\n    strict: true,\n    decode: (i) => option_.fromNullable(i),\n    encode: (a) => option_.getOrUndefined(a)\n  })\n}\n\n/**\n * Transforms strings into an Option type, effectively filtering out empty or\n * whitespace-only strings by trimming them and checking their length. Returns\n * `none` for invalid inputs and `some` for valid non-empty strings.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category Option transformations\n * @since 3.10.0\n */\nexport class OptionFromNonEmptyTrimmedString extends transform(String$, OptionFromSelf(NonEmptyTrimmedString), {\n  strict: true,\n  decode: (i) => option_.filter(option_.some(i.trim()), string_.isNonEmpty),\n  encode: (a) => option_.getOrElse(a, () => \"\")\n}) {}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <Right extends Schema.All>(right: Right) =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <Left extends Schema.All>(left: Left) =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <Right extends Schema.All, Left extends Schema.All>(\n  right: Right,\n  left: Left\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableDeclare<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    [R, L]\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Either<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Right\"]>\n        right: Right\n      }>,\n      Struct<{\n        _tag: Literal<[\"Left\"]>\n        left: Left\n      }>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const out = transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: (i) => eitherDecode(i),\n      encode: (a) =>\n        either_.match(a, {\n          onLeft: makeLeftEncoded,\n          onRight: makeRightEncoded\n        })\n    }\n  )\n  return out as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromUnion<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      transform<Right, Struct<{ _tag: Literal<[\"Right\"]>; right: SchemaClass<Schema.Type<Right>> }>>,\n      transform<Left, Struct<{ _tag: Literal<[\"Left\"]>; right: SchemaClass<Schema.Type<Left>> }>>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}\n\n/**\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n * ```\n *\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromUnion = <Right extends Schema.All, Left extends Schema.All>({ left, right }: {\n  readonly left: Left\n  readonly right: Right\n}): EitherFromUnion<Right, Left> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: (i) => makeRightEncoded(i),\n    encode: (a) => a.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: (i) => makeLeftEncoded(i),\n    encode: (a) => a.left\n  })\n  const out = transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (i) => i._tag === \"Left\" ? either_.left(i.left) : either_.right(i.right),\n      encode: (a) =>\n        either_.match(a, {\n          onLeft: makeLeftEncoded,\n          onRight: makeRightEncoded\n        })\n    }\n  )\n  return out as any\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<Map<K, V>> => {\n  return (fc) => {\n    const items = fc.array(fc.tuple(key(fc), value(fc)))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))\n  }\n}\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 3.10.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\n/**\n * @category Map\n * @since 3.10.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, ReadonlyMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport function ReadonlyMap<K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> {\n  return transform(\n    Array$(Tuple(key, value)),\n    ReadonlyMapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => new Map(i),\n      encode: (a) => Array.from(a.entries())\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, MapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/** @ignore */\nfunction map<K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> {\n  return transform(\n    Array$(Tuple(key, value)),\n    MapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => new Map(i),\n      encode: (a) => Array.from(a.entries())\n    }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 3.10.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): SchemaClass<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record to be decoded into a ReadonlyMap\"\n    }),\n    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (i) => new Map(Object.entries(i)),\n      encode: (a) => Object.fromEntries(a)\n    }\n  )\n\n/**\n * @category Map transformations\n * @since 3.10.0\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): SchemaClass<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record to be decoded into a Map\"\n    }),\n    MapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (i) => new Map(Object.entries(i)),\n      encode: (a) => Object.fromEntries(a)\n    }\n  )\n\nconst setArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))\n  }\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 3.10.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Set\n * @since 3.10.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any>\n  extends transform<Array$<Value>, ReadonlySetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 3.10.0\n */\nexport function ReadonlySet<Value extends Schema.Any>(value: Value): ReadonlySet$<Value> {\n  return transform(\n    Array$(value),\n    ReadonlySetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => new Set(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Set$<Value extends Schema.Any>\n  extends transform<Array$<Value>, SetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/** @ignore */\nfunction set<Value extends Schema.Any>(value: Value): Set$<Value> {\n  return transform(\n    Array$(value),\n    SetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => new Set(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 3.10.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer({ min: 0, max: 18 }))\n    .map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$.annotations({ description: \"a string to be decoded into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (i, _, ast) =>\n      bigDecimal_.fromString(i).pipe(option_.match({\n        onNone: () =>\n          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (a) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(a)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimalFromNumber extends transform(\n  Number$.annotations({ description: \"a number to be decoded into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (i) => bigDecimal_.unsafeFromNumber(i),\n    encode: (a) => bigDecimal_.unsafeToNumber(a)\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanBigDecimal =\n  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(min)\n    return self.pipe(\n      filter((a) => bigDecimal_.greaterThan(a, min), {\n        schemaId: GreaterThanBigDecimalSchemaId,\n        [GreaterThanBigDecimalSchemaId]: { min },\n        title: `greaterThanBigDecimal(${formatted})`,\n        description: `a BigDecimal greater than ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigDecimal =\n  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(min)\n    return self.pipe(\n      filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n        schemaId: GreaterThanOrEqualToBigDecimalSchemaId,\n        [GreaterThanOrEqualToBigDecimalSchemaId]: { min },\n        title: `greaterThanOrEqualToBigDecimal(${formatted})`,\n        description: `a BigDecimal greater than or equal to ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanBigDecimal =\n  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(max)\n    return self.pipe(\n      filter((a) => bigDecimal_.lessThan(a, max), {\n        schemaId: LessThanBigDecimalSchemaId,\n        [LessThanBigDecimalSchemaId]: { max },\n        title: `lessThanBigDecimal(${formatted})`,\n        description: `a BigDecimal less than ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigDecimal =\n  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n    const formatted = bigDecimal_.format(max)\n    return self.pipe(\n      filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n        schemaId: LessThanOrEqualToBigDecimalSchemaId,\n        [LessThanOrEqualToBigDecimalSchemaId]: { max },\n        title: `lessThanOrEqualToBigDecimal(${formatted})`,\n        description: `a BigDecimal less than or equal to ${formatted}`,\n        ...annotations\n      })\n    )\n  }\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const positiveBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => bigDecimal_.isPositive(a), {\n        schemaId: PositiveBigDecimalSchemaId,\n        title: \"positiveBigDecimal\",\n        description: `a positive BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({ identifier: \"PositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonNegativeBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a.value >= 0n, {\n        schemaId: NonNegativeBigDecimalSchemaId,\n        title: \"nonNegativeBigDecimal\",\n        description: `a non-negative BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({ identifier: \"NonNegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const negativeBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => bigDecimal_.isNegative(a), {\n        schemaId: NegativeBigDecimalSchemaId,\n        title: \"negativeBigDecimal\",\n        description: `a negative BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({ identifier: \"NegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonPositiveBigDecimal =\n  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>\n  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>\n    self.pipe(\n      filter((a) => a.value <= 0n, {\n        schemaId: NonPositiveBigDecimalSchemaId,\n        title: \"nonPositiveBigDecimal\",\n        description: `a non-positive BigDecimal`,\n        ...annotations\n      })\n    )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({ identifier: \"NonPositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const betweenBigDecimal = <S extends Schema.Any>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<Schema.Type<S>>\n) =>\n<A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {\n  const formattedMinimum = bigDecimal_.format(minimum)\n  const formattedMaximum = bigDecimal_.format(maximum)\n  return self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      schemaId: BetweenBigDecimalSchemaId,\n      [BetweenBigDecimalSchemaId]: { maximum, minimum },\n      title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,\n      description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(\n    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>\n  ): transform<S, filter<SchemaClass<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      {\n        strict: false,\n        decode: (i) => bigDecimal_.clamp(i, { minimum, maximum }),\n        encode: identity\n      }\n    )\n\nconst chunkArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)\n  }\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Chunk<Value extends Schema.Any>\n  extends transform<Array$<Value>, ChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport function Chunk<Value extends Schema.Any>(value: Value): Chunk<Value> {\n  return transform(\n    Array$(value),\n    ChunkFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => i.length === 0 ? chunk_.empty() : chunk_.fromIterable(i),\n      encode: (a) => chunk_.toReadonlyArray(a)\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunk<Value extends Schema.Any>\n  extends transform<NonEmptyArray<Value>, NonEmptyChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport function NonEmptyChunk<Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> {\n  return transform(\n    NonEmptyArray(value),\n    NonEmptyChunkFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => chunk_.unsafeFromNonEmptyArray(i),\n      encode: (a) => chunk_.toReadonlyArray(a)\n    }\n  )\n}\n\nconst decodeData = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(decodeData)\n\nconst dataPretty = <A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), decodeData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface DataFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    DataFromSelf<Value>,\n    Schema.Type<Value>,\n    Schema.Encoded<Value>,\n    [Value]\n  >\n{}\n\n/**\n * Type and Encoded must extend `Readonly<Record<string, any>> |\n * ReadonlyArray<any>` to be compatible with this API.\n *\n * @category Data transformations\n * @since 3.10.0\n */\nexport const DataFromSelf = <\n  S extends Schema.Any,\n  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,\n  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>\n>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): DataFromSelf<S> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(value)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.13.3\n */\nexport interface Data<Value extends Schema.Any>\n  extends transform<Value, DataFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * Type and Encoded must extend `Readonly<Record<string, any>> |\n * ReadonlyArray<any>` to be compatible with this API.\n *\n * @category Data transformations\n * @since 3.10.0\n */\nexport const Data = <\n  S extends Schema.Any,\n  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,\n  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>\n>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): Data<S> => {\n  return transform(\n    value,\n    DataFromSelf(typeSchema(value)),\n    {\n      strict: false,\n      decode: (i) => decodeData(i),\n      encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)\n    }\n  )\n}\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\ntype ClassAnnotations<Self, A> =\n  | Annotations.Schema<Self>\n  | readonly [\n    Annotations.Schema<Self> | undefined,\n    (Annotations.Schema<Self> | undefined)?,\n    Annotations.Schema<A>?\n  ]\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<C extends new(...args: Array<any>) => any>(this: C, ...args: ConstructorParameters<C>): InstanceType<C>\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(\n    fields: NewFields | HasFields<NewFields>,\n    annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & NewFields,\n      I & Struct.Encoded<NewFields>,\n      R | Struct.Context<NewFields>,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [RefineSchemaId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n *  someField: Schema.String\n * }) {\n *  someMethod() {\n *    return this.someField + \"bar\"\n *  }\n * }\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n *  a: Schema.String\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n *   \"MyError\",\n *   {\n *     module: Schema.String,\n *     method: Schema.String,\n *     description: Schema.String\n *   }\n * ) {\n *   get message(): string {\n *     return `${this.module}.${this.method}: ${this.description}`\n *   }\n * }\n * ```\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: tag<Tag> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n    get message(): string {\n      return `{ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } }`\n    }\n  } as any\n}\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of util_.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\n/**\n * @category Constructor utils\n * @since 3.13.4\n */\nexport type MakeOptions = boolean | {\n  readonly disableValidation?: boolean | undefined\n}\n\nfunction getDisableValidationMakeOption(options: MakeOptions | undefined): boolean {\n  return Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n}\n\nconst astCache = globalValue(\"effect/Schema/astCache\", () => new WeakMap<any, AST.AST>())\n\nconst getClassAnnotations = <Self, A>(\n  annotations: ClassAnnotations<Self, A> | undefined\n): [Annotations.Schema<Self>?, Annotations.Schema<Self>?, Annotations.Schema<A>?] => {\n  if (annotations === undefined) {\n    return []\n  } else if (Array.isArray(annotations)) {\n    return annotations as any\n  } else {\n    return [annotations] as any\n  }\n}\n\nconst makeClass = <Fields extends Struct.Fields>(\n  { Base, annotations, disableToString, fields, identifier, kind, schema }: {\n    kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n    identifier: string\n    schema: Schema.Any\n    fields: Fields\n    Base: new(...args: ReadonlyArray<any>) => any\n    annotations?: ClassAnnotations<any, any> | undefined\n    disableToString?: boolean | undefined\n  }\n): any => {\n  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)\n\n  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations)\n\n  const typeSchema_ = typeSchema(schema)\n\n  const declarationSurrogate = typeSchema_.annotations({\n    identifier,\n    ...typeAnnotations\n  })\n\n  const typeSide = typeSchema_.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Type side)`,\n    ...typeAnnotations\n  })\n\n  const constructorSchema = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)`,\n    ...typeAnnotations\n  })\n\n  const encodedSide = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,\n    ...encodedAnnotations\n  })\n\n  const transformationSurrogate = schema.annotations({\n    [AST.JSONIdentifierAnnotationId]: identifier,\n    ...encodedAnnotations,\n    ...typeAnnotations,\n    ...transformationAnnotations\n  })\n\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(constructorSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast(): AST.AST {\n      let out = astCache.get(this)\n      if (out) {\n        return out\n      }\n\n      const declaration: Schema.Any = declare(\n        [schema],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          // @ts-expect-error\n          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: declarationSurrogate.ast,\n          ...typeAnnotations\n        }\n      )\n\n      out = transform(\n        encodedSide,\n        declaration,\n        {\n          strict: true,\n          decode: (i) => new this(i, true),\n          encode: identity\n        }\n      ).annotations({\n        [AST.SurrogateAnnotationId]: transformationSurrogate.ast,\n        ...transformationAnnotations\n      }).ast\n\n      astCache.set(this, out)\n\n      return out\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields | HasFields<NewFields>,\n        annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFieldsOr)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFields: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n            .join(\", \")\n        } })`\n      },\n      configurable: true,\n      writable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 3.10.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int,\n  startTimeMillis: Int\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 3.10.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 3.10.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  {\n    strict: true,\n    decode: (i) => fiberIdDecode(i),\n    encode: (a) => fiberIdEncode(a)\n  }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 3.10.0\n */\nexport type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n\nconst causeDieEncoded = <Defect extends Schema.Any>(defect: Defect) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E extends Schema.Any>(error: E) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nlet causeEncodedId = 0\n\nconst causeEncoded = <E extends Schema.All, D extends Schema.All>(\n  error: E,\n  defect: D\n): SchemaClass<\n  CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n  CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n  Schema.Context<E> | Schema.Context<D>\n> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  const suspended = suspend((): Schema<\n    CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<E> | Schema.Context<D>\n  > => out)\n  const out = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error_),\n    causeDieEncoded(defect_),\n    CauseInterruptEncoded,\n    Struct({\n      _tag: Literal(\"Sequential\"),\n      left: suspended,\n      right: suspended\n    }),\n    Struct({\n      _tag: Literal(\"Parallel\"),\n      left: suspended,\n      right: suspended\n    })\n  ).annotations({\n    title: `CauseEncoded<${format(error)}>`,\n    [AST.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`\n  })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, D, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableDeclare<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    [E, D]\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): CauseFromSelf<E, D> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      title: `Cause<${error.ast}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Cause<E extends Schema.All, D extends Schema.All> extends\n  transform<\n    SchemaClass<\n      CauseEncoded<Schema.Type<E>, Schema.Type<Defect>>,\n      CauseEncoded<Schema.Encoded<E>, Schema.Encoded<Defect>>,\n      Schema.Context<E> | Schema.Context<D>\n    >,\n    CauseFromSelf<SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): Cause<E, D> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  const out = transform(\n    causeEncoded(error_, defect_),\n    CauseFromSelf({ error: typeSchema(error_), defect: typeSchema(defect_) }),\n    {\n      strict: false,\n      decode: (i) => causeDecode(i),\n      encode: (a) => causeEncode(a)\n    }\n  )\n  return out as any\n}\n\n/**\n * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\n * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\n * or converts other values to their string representations.\n *\n * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\n * or other values into their string forms.\n *\n * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.\n *\n * @category defect\n * @since 3.10.0\n */\nexport class Defect extends transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (i) => {\n      if (Predicate.isObject(i) && \"message\" in i && typeof i.message === \"string\") {\n        const err = new Error(i.message, { cause: i })\n        if (\"name\" in i && typeof i.name === \"string\") {\n          err.name = i.name\n        }\n        err.stack = \"stack\" in i && typeof i.stack === \"string\" ? i.stack : \"\"\n        return err\n      }\n      return String(i)\n    },\n    encode: (a) => {\n      if (a instanceof Error) {\n        return {\n          name: a.name,\n          message: a.message\n          // no stack because of security reasons\n        }\n      }\n      return internalCause_.prettyErrorMessage(a)\n    }\n  }\n).annotations({ identifier: \"Defect\" }) {}\n\n/**\n * @category Exit utils\n * @since 3.10.0\n */\nexport type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E extends Schema.All, D extends Schema.All>(\n  error: E,\n  defect: D\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  })\n\nconst exitSuccessEncoded = <A extends Schema.All>(\n  value: A\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  })\n\nconst exitEncoded = <A extends Schema.All, E extends Schema.All, D extends Schema.Any>(\n  value: A,\n  error: E,\n  defect: D\n) => {\n  return Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`\n  })\n}\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All>\n  extends\n    AnnotableDeclare<\n      ExitFromSelf<A, E, D>,\n      exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n      exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n      [A, E, D]\n    >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): ExitFromSelf<A, E, D> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      title: `Exit<${success.ast}, ${failure.ast}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Failure\"]>\n        cause: SchemaClass<\n          CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n          CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n          Schema.Context<E> | Schema.Context<D>\n        >\n      }>,\n      Struct<{\n        _tag: Literal<[\"Success\"]>\n        value: A\n      }>\n    ]>,\n    ExitFromSelf<SchemaClass<Schema.Type<A>>, SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): Exit<A, E, D> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  const defect_ = asSchema(defect)\n  const out = transform(\n    exitEncoded(success_, failure_, defect_),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: typeSchema(defect_) }),\n    {\n      strict: false,\n      decode: (i) => exitDecode(i),\n      encode: (a) =>\n        a._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: a.cause } as const\n          : { _tag: \"Success\", value: a.value } as const\n    }\n  )\n  return out as any\n}\n\nconst hashSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(\n      hashSet_.fromIterable\n    )\n  }\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, HashSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport function HashSet<Value extends Schema.Any>(value: Value): HashSet<Value> {\n  return transform(\n    Array$(value),\n    HashSetFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => hashSet_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => {\n  const items = fc.array(fc.tuple(key(fc), value(fc)))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashMap_.fromIterable)\n}\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, HashMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  return transform(\n    Array$(Tuple(key, value)),\n    HashMapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),\n    {\n      strict: true,\n      decode: (i) => hashMap_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst listArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)\n  }\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface List<Value extends Schema.Any>\n  extends transform<Array$<Value>, ListFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport function List<Value extends Schema.Any>(value: Value): List<Value> {\n  return transform(\n    Array$(value),\n    ListFromSelf(typeSchema(asSchema(value))),\n    {\n      strict: true,\n      decode: (i) => list_.fromIterable(i),\n      encode: (a) => Array.from(a)\n    }\n  )\n}\n\nconst sortedSetArbitrary = <A>(\n  item: LazyArbitrary<A>,\n  ord: Order.Order<A>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<sortedSet_.SortedSet<A>> =>\n(fc) => {\n  const items = fc.array(item(fc))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) =>\n    sortedSet_.fromIterable(as, ord)\n  )\n}\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, SortedSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport function SortedSet<Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> {\n  const to = typeSchema(asSchema(value))\n  return transform(\n    Array$(value),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (i) => sortedSet_.fromIterable(i, ordA),\n      encode: (a) => Array.from(sortedSet_.values(a))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n *\n * @category boolean constructors\n * @since 3.10.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  {\n    strict: true,\n    decode: (i) => Predicate.isTruthy(i),\n    encode: identity\n  }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * Converts an `string` value into its corresponding `boolean`\n * (\"true\" as `true` and \"false\" as `false`).\n *\n * @category boolean transformations\n * @since 3.11.0\n */\nexport class BooleanFromString extends transform(\n  Literal(\"true\", \"false\").annotations({ description: \"a string to be decoded into a boolean\" }),\n  Boolean$,\n  {\n    strict: true,\n    decode: (i) => i === \"true\",\n    encode: (a) => a ? \"true\" : \"false\"\n  }\n).annotations({ identifier: \"BooleanFromString\" }) {}\n\n/**\n * @category Config validations\n * @since 3.10.0\n */\nexport const Config = <A, I extends string>(name: string, schema: Schema<A, I>): config_.Config<A> => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((s) =>\n      decodeUnknownEither(s).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], ParseResult.TreeFormatter.formatIssueSync(error)))\n      )\n    )\n  )\n}\n\n// ---------------------------------------------\n// Serializable\n// ---------------------------------------------\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolSerializable: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbol\"\n)\n\n/**\n * The `Serializable` trait allows objects to define their own schema for\n * serialization.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace Serializable {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Serializable<any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializable = <S extends Serializable.All>(\n  serializable: S\n): Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>> => serializable as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const serializableSchema = <A, I, R>(self: Serializable<A, I, R>): Schema<A, I, R> => self[symbolSerializable]\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serialize = <A, I, R>(self: Serializable<A, I, R>): Effect.Effect<I, ParseResult.ParseError, R> =>\n  encodeUnknown(self[symbolSerializable])(self)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserialize: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R> =>\n    decodeUnknown(self[symbolSerializable])(value)\n)\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolWithResult: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbolResult\"\n)\n\n/**\n * The `WithResult` trait is designed to encapsulate the outcome of an\n * operation, distinguishing between success and failure cases. Each case is\n * associated with a schema that defines the structure and types of the success\n * or failure data.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace WithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never\n  /**\n   * @since 3.10.0\n   */\n  export type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never\n  /**\n   * @since 3.10.0\n   */\n  export type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = WithResult<any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | WithResult<any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asWithResult = <WR extends WithResult.All>(\n  withExit: WR\n): WithResult<\n  WithResult.Success<WR>,\n  WithResult.SuccessEncoded<WR>,\n  WithResult.Failure<WR>,\n  WithResult.FailureEncoded<WR>,\n  WithResult.Context<WR>\n> => withExit as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const failureSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<FA, FI, R> =>\n  self[symbolWithResult].failure\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const successSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<SA, SI, R> =>\n  self[symbolWithResult].success\n\nconst exitSchemaCache = globalValue(\n  \"effect/Schema/Serializable/exitSchemaCache\",\n  () => new WeakMap<object, Schema<any, any, any>>()\n)\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const exitSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<\n  exit_.Exit<SA, FA>,\n  ExitEncoded<SI, FI, unknown>,\n  R\n> => {\n  const proto = Object.getPrototypeOf(self)\n  if (!(symbolWithResult in proto)) {\n    return Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n  }\n  let schema = exitSchemaCache.get(proto)\n  if (schema === undefined) {\n    schema = Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n    exitSchemaCache.set(proto, schema)\n  }\n  return schema\n}\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <FA>(value: FA): <SA, SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<FI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<FA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA>(value: SA): <SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<SA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeExit: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: exit_.Exit<SA, FA>): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: exit_.Exit<SA, FA>\n): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R> => encode(exitSchema(self))(value))\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeExit: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: unknown\n): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R> => decodeUnknown(exitSchema(self))(value))\n\n// ---------------------------------------------\n// SerializableWithResult\n// ---------------------------------------------\n\n/**\n * The `SerializableWithResult` trait is specifically designed to model remote\n * procedures that require serialization of their input and output, managing\n * both successful and failed outcomes.\n *\n * This trait combines functionality from both the `Serializable` and `WithResult`\n * traits to handle data serialization and the bifurcation of operation results\n * into success or failure categories.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace SerializableWithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializableWithResult = <SWR extends SerializableWithResult.All>(\n  procedure: SWR\n): SerializableWithResult<\n  Serializable.Type<SWR>,\n  Serializable.Encoded<SWR>,\n  Serializable.Context<SWR>,\n  WithResult.Success<SWR>,\n  WithResult.SuccessEncoded<SWR>,\n  WithResult.Failure<SWR>,\n  WithResult.FailureEncoded<SWR>,\n  WithResult.Context<SWR>\n> => procedure as any\n\n/**\n * @since 3.10.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @since 3.10.0\n   */\n  export type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n *  failure: Schema.String,\n *  success: Schema.Number,\n *  payload: { id: Schema.String }\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(\n    tag: Tag,\n    options: {\n      failure: Failure\n      success: Success\n      payload: Payload\n    },\n    annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Payload>>>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: tag<Tag> } & Payload,\n      Success,\n      Failure\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, options.payload)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      static success = options.success\n      static failure = options.failure\n      get [symbolSerializable]() {\n        return this.constructor\n      }\n      get [symbolWithResult]() {\n        return {\n          failure: options.failure,\n          success: options.success\n        }\n      }\n    } as any\n  }\n\n// -------------------------------------------------------------------------------------------------\n// Equivalence compiler\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.\n *\n * @category Equivalence\n * @since 3.10.0\n */\nexport const equivalence = <A, I, R>(schema: Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getEquivalenceAnnotation = AST.getAnnotation<AST.EquivalenceAnnotation<any, any>>(AST.EquivalenceAnnotationId)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getEquivalenceAnnotation(ast)\n  if (option_.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const encodedParameter = AST.getEncodedParameter(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(encodedParameter)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecordOrArray(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n\nconst SymbolStruct = TaggedStruct(\"symbol\", {\n  key: String$\n}).annotations({ description: \"an object to be decoded into a globally shared symbol\" })\n\nconst SymbolFromStruct = transformOrFail(\n  SymbolStruct,\n  SymbolFromSelf,\n  {\n    strict: true,\n    decode: (i) => decodeSymbol(i.key),\n    encode: (a, _, ast) => ParseResult.map(encodeSymbol(a, ast), (key) => SymbolStruct.make({ key }))\n  }\n)\n\n/** @ignore */\nclass PropertyKey$ extends Union(String$, Number$, SymbolFromStruct).annotations({ identifier: \"PropertyKey\" }) {}\n\nexport {\n  /**\n   * @since 3.12.5\n   */\n  PropertyKey$ as PropertyKey\n}\n\n/**\n * @category ArrayFormatter\n * @since 3.12.5\n */\nexport class ArrayFormatterIssue extends Struct({\n  _tag: propertySignature(Literal(\n    \"Pointer\",\n    \"Unexpected\",\n    \"Missing\",\n    \"Composite\",\n    \"Refinement\",\n    \"Transformation\",\n    \"Type\",\n    \"Forbidden\"\n  )).annotations({ description: \"The tag identifying the type of parse issue\" }),\n  path: propertySignature(Array$(PropertyKey$)).annotations({\n    description: \"The path to the property where the issue occurred\"\n  }),\n  message: propertySignature(String$).annotations({ description: \"A descriptive message explaining the issue\" })\n}).annotations({\n  identifier: \"ArrayFormatterIssue\",\n  description: \"Represents an issue returned by the ArrayFormatter formatter\"\n}) {}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","dateTime","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fastCheck_","fiberId_","dual","identity","globalValue","hashMap_","hashSet_","internalCause_","errors_","schemaId_","util_","list_","number_","option_","ParseResult","pipeArguments","Predicate","redacted_","Request","scheduler_","AST","sortedSet_","string_","struct_","TypeId","Symbol","for","make","ast","SchemaClass","variance","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","Type","Encoded","Context","_A","_","_I","_R","makeStandardResult","exit","isSuccess","value","makeStandardFailureResult","pretty","cause","message","issues","makeStandardFailureFromParseIssue","issue","map","ArrayFormatter","formatIssue","path","standardSchemaV1","schema","overrideOptions","decodeUnknown","errors","StandardSchemaV1Class","version","vendor","validate","scheduler","SyncScheduler","fiber","runFork","matchEffect","onFailure","onSuccess","succeed","flush","unsafePoll","Promise","resolve","addObserver","builtInAnnotations","schemaId","SchemaIdAnnotationId","MessageAnnotationId","missingMessage","MissingMessageAnnotationId","identifier","IdentifierAnnotationId","title","TitleAnnotationId","description","DescriptionAnnotationId","examples","ExamplesAnnotationId","default","DefaultAnnotationId","documentation","DocumentationAnnotationId","jsonSchema","JSONSchemaAnnotationId","arbitrary","ArbitraryAnnotationId","PrettyAnnotationId","equivalence","EquivalenceAnnotationId","concurrency","ConcurrencyAnnotationId","batching","BatchingAnnotationId","parseIssueTitle","ParseIssueTitleAnnotationId","parseOptions","ParseOptionsAnnotationId","decodingFallback","DecodingFallbackAnnotationId","toASTAnnotations","out","key","id","asSchema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","Object","keys","filter","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","spans","h","ts","isLiteral","i","length","item","next","push","TemplateLiteralSpan","isNonEmptyArray","getTemplateLiteralParserCoercedElement","encoded","_tag","isString","s","transform","strict","compose","NumberFromString","members","hasCoercions","member","types","coerced","TemplateLiteralParser","params","encodedSchemas","elements","schemas","param","element","from","re","getTemplateLiteralCapturingRegExp","to","Tuple","AutoTitleAnnotationId","TemplateLiteralParserClass","transformOrFail","match","exec","slice","fail","source","JSON","stringify","tuple","join","declareConstructor","typeParameters","makeDeclareClass","Declaration","tp","declarePrimitive","input","DeclareClass","declare","Array","isArray","BrandSchemaId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","a","either","isLeft","some","left","v","none","InstanceOfSchemaId","instanceOf","name","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","Number","getDefaultUnionAST","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","ElementImpl","OptionalType","optionalElement","_Token","type","isOptional","getDefaultTupleTypeAST","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","args","makeArrayClass","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","ArrayEnsure","ensure","NonEmptyArrayEnsure","of","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","undefined","PropertySignatureTransformation","mergeSignatureAnnotations","PropertySignatureTypeId","isPropertySignature","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","onNone","onSome","pruneUndefined","pruned","Transformation","transformation","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","flatMap","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf","isNotNull","isNotUndefined","optional","optionalWith","preserveMissingMessageAnnotation","pickAnnotations","getDefaultTypeLiteralAST","fields","records","ownKeys","pss","transformations","field","toAnnotations","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","TypeLiteral","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","BrandClass","brand","annotation","getBrandAnnotation","brands","BrandAnnotationId","partial","partialWith","required","mutable","intersectTypeLiterals","x","y","isTypeLiteral","findIndex","extendAST","concat","Error","getSchemaExtendErrorMessage","preserveRefinementAnnotations","omitAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","xs","ys","isStringKeyword","isNumber","isNumberKeyword","isBoolean","isBooleanKeyword","isRefinement","Suspend","f","propertySignatureTransformations","composeTransformation","FinalTransformation","fromA","fromI","toI","toA","isTransformation","isTypeLiteralTransformation","extend","that","makeTransformationClass","suspend","RefineSchemaId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","Pointer","toFilterParseIssue","isSingle","filterMap","Composite","filterEffect","filterReturnType","TransformationClass","_options","_ast","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedSchemaId","trimmed","trim","pattern","MaxLengthSchemaId","maxLength","MinLengthSchemaId","minLength","LengthSchemaId","Math","max","floor","min","PatternSchemaId","regex","lastIndex","test","StartsWithSchemaId","startsWith","formatted","EndsWithSchemaId","endsWith","IncludesSchemaId","includes","searchString","LowercasedSchemaId","lowercased","toLowerCase","Lowercased","UppercasedSchemaId","uppercased","toUpperCase","Uppercased","CapitalizedSchemaId","capitalized","Capitalized","UncapitalizedSchemaId","uncapitalized","Uncapitalized","Char","nonEmptyString","Lowercase","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","NonEmptyTrimmedString","Trim","split","separator","getErrorMessage","e","getParseJsonTransformation","try","parse","reviver","catch","replacer","space","ParseJsonSchemaId","parseJson","schemaOrOptions","NonEmptyString","UUIDSchemaId","uuidRegexp","UUID","fc","uuid","ULIDSchemaId","ulidRegexp","ULID","ulid","URLFromSelf","URL","webUrl","url","URL$","FiniteSchemaId","finite","isFinite","GreaterThanSchemaId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToSchemaId","greaterThanOrEqualTo","minimum","MultipleOfSchemaId","multipleOf","divisor","positiveDivisor","abs","remainder","IntSchemaId","int","isSafeInteger","LessThanSchemaId","lessThan","exclusiveMaximum","LessThanOrEqualToSchemaId","lessThanOrEqualTo","maximum","BetweenSchemaId","between","NonNaNSchemaId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberSchemaId","JsonNumber","Not","not","encodeSymbol","sym","keyFor","decodeSymbol","Symbol$","GreaterThanBigIntSchemaId","GreaterThanBigintSchemaId","greaterThanBigInt","GreaterThanOrEqualToBigIntSchemaId","greaterThanOrEqualToBigInt","LessThanBigIntSchemaId","lessThanBigInt","LessThanOrEqualToBigIntSchemaId","lessThanOrEqualToBigInt","BetweenBigIntSchemaId","BetweenBigintSchemaId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","fromNumber","toNumber","redactedArbitrary","toComposite","eff","actual","mapBoth","redactedParse","isRedacted","RedactedFromSelf","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigInt","nanos","maxSafeNat","millis","DurationFromNanos","duration","toNanos","NonNegativeInt","DurationFromMillis","toMillis","DurationValueMillis","DurationValueNanos","DurationValueInfinity","durationValueInfinity","DurationValue","FiniteHRTime","InfiniteHRTime","HRTime","isDurationValue","Duration","seconds","clampDuration","betweenDuration","LessThanDurationSchemaId","lessThanDuration","LessThanOrEqualToDurationSchemaId","lessThanOrEqualToDuration","GreaterThanDurationSchemaId","greaterThanDuration","GreaterThanOrEqualToDurationSchemaId","greaterThanOrEqualToDuration","BetweenDurationSchemaId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8","Uint8Array$","Uint8Array","makeUint8ArrayTransformation","decodeException","Uint8ArrayFromBase64","decodeBase64","encodeBase64","Uint8ArrayFromBase64Url","decodeBase64Url","encodeBase64Url","Uint8ArrayFromHex","decodeHex","encodeHex","makeEncodingTransformation","StringFromBase64","decodeBase64String","StringFromBase64Url","decodeBase64UrlString","StringFromHex","decodeHexString","StringFromUriComponent","decodeUriComponent","encodeUriComponent","encodeException","MinItemsSchemaId","minItems","n","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsSchemaId","maxItems","ItemsCountSchemaId","itemsCount","getNumberIndexedAccess","headNonEmpty","headOrElse","fallback","ValidDateSchemaId","validDate","getTime","noInvalidDate","LessThanDateSchemaId","lessThanDate","formatDate","LessThanOrEqualToDateSchemaId","lessThanOrEqualToDate","GreaterThanDateSchemaId","greaterThanDate","GreaterThanOrEqualToDateSchemaId","greaterThanOrEqualToDate","BetweenDateSchemaId","betweenDate","DateFromSelfSchemaId","DateFromSelf","isDate","date","Date","ValidDateFromSelf","DateFromString","Date$","DateFromNumber","DateTimeUtcFromSelf","isDateTime","isUtc","unsafeFromDate","decodeDateTimeUtc","unsafeMake","formatUnknown","DateTimeUtcFromNumber","toEpochMillis","DateTimeUtcFromDate","toDateUtc","DateTimeUtc","formatIso","timeZoneOffsetArbitrary","integer","zoneMakeOffset","TimeZoneOffsetFromSelf","isTimeZoneOffset","zone","TimeZoneOffset","offset","timeZoneNamedArbitrary","constantFrom","Intl","supportedValuesOf","zoneUnsafeMakeNamed","TimeZoneNamedFromSelf","isTimeZoneNamed","TimeZoneNamed","TimeZoneFromSelf","TimeZone","zoneFromString","zoneToString","timeZoneArbitrary","DateTimeZonedFromSelf","isZoned","timeZone","unsafeMakeZoned","DateTimeZoned","makeZonedFromString","formatIsoZoned","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","ctx","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","value_","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","OptionFromNonEmptyTrimmedString","isNonEmpty","getOrElse","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","mapArbitrary","items","array","depthIdentifier","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","b","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","val","normalize","bigDecimalArbitrary","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","BigDecimalFromNumber","unsafeFromNumber","unsafeToNumber","GreaterThanBigDecimalSchemaId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalSchemaId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalSchemaId","lessThanBigDecimal","LessThanOrEqualToBigDecimalSchemaId","lessThanOrEqualToBigDecimal","PositiveBigDecimalSchemaId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalSchemaId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalSchemaId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalSchemaId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalSchemaId","betweenBigDecimal","formattedMinimum","formattedMaximum","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","NonEmptyChunkFromSelf","NonEmptyChunk","decodeData","struct","dataArbitrary","dataPretty","d","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","TaggedErrorClass","disableToString","getASTDuplicatePropertySignatureErrorMessage","disableValidation","astCache","WeakMap","getClassAnnotations","classSymbol","typeAnnotations","transformationAnnotations","encodedAnnotations","typeSchema_","declarationSurrogate","typeSide","constructorSchema","encodedSide","transformationSurrogate","JSONIdentifierAnnotationId","fallbackInstanceOf","klass","get","declaration","arb","SurrogateAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","defineProperty","configurable","writable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeEncodedId","causeEncoded","error_","defect_","suspended","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","Defect","err","stack","prettyErrorMessage","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","BooleanFromString","Config","string","mapOrFail","InvalidData","TreeFormatter","formatIssueSync","symbolSerializable","asSerializable","serializable","serializableSchema","serialize","deserialize","symbolWithResult","asWithResult","withExit","failureSchema","successSchema","exitSchemaCache","exitSchema","proto","getPrototypeOf","serializeFailure","deserializeFailure","serializeSuccess","deserializeSuccess","serializeExit","deserializeExit","asSerializableWithResult","procedure","TaggedRequest","payload","TaggedRequestClass","go","getEquivalenceAnnotation","getAnnotation","hook","isSome","getEquivalenceUnsupportedErrorMessage","memoizeThunk","annotatedAST","len","j","aStringKeys","aSymbolKeys","getOwnPropertySymbols","aHas","hasOwnProperty","call","bHas","bSymbolKeys","bStringKeys","encodedParameter","getEncodedParameter","isSymbolKeyword","aKeys","searchTree","getSearchTree","candidates","isRecordOrArray","buckets","otherwise","tuples","SymbolStruct","SymbolFromStruct","PropertyKey$","PropertyKey","ArrayFormatterIssue"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}