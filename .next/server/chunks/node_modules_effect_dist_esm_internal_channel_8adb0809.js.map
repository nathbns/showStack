{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"channel.js","sources":["file:///Users/nathan/Desktop/next/showStack/node_modules/effect/src/internal/channel.ts"],"sourcesContent":["import * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport * as Deferred from \"../Deferred.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport * as Fiber from \"../Fiber.js\"\nimport * as FiberRef from \"../FiberRef.js\"\nimport { constVoid, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as Layer from \"../Layer.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport type * as MergeState from \"../MergeState.js\"\nimport type * as MergeStrategy from \"../MergeStrategy.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty, type Predicate } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as SingleProducerAsyncInput from \"../SingleProducerAsyncInput.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type * as Types from \"../Types.js\"\nimport * as executor from \"./channel/channelExecutor.js\"\nimport type * as ChannelState from \"./channel/channelState.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as mergeState from \"./channel/mergeState.js\"\nimport * as mergeStrategy_ from \"./channel/mergeStrategy.js\"\nimport * as singleProducerAsyncInput from \"./channel/singleProducerAsyncInput.js\"\nimport * as coreEffect from \"./core-effect.js\"\nimport * as core from \"./core-stream.js\"\nimport * as MergeDecisionOpCodes from \"./opCodes/channelMergeDecision.js\"\nimport * as MergeStateOpCodes from \"./opCodes/channelMergeState.js\"\nimport * as ChannelStateOpCodes from \"./opCodes/channelState.js\"\nimport * as tracer from \"./tracer.js\"\n\n/** @internal */\nexport const acquireUseRelease = <Acquired, OutErr, Env, OutElem1, InElem, InErr, OutDone, InDone>(\n  acquire: Effect.Effect<Acquired, OutErr, Env>,\n  use: (a: Acquired) => Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  release: (a: Acquired, exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n): Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env> =>\n  core.flatMap(\n    core.fromEffect(\n      Ref.make<\n        (exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n      >(() => Effect.void)\n    ),\n    (ref) =>\n      pipe(\n        core.fromEffect(\n          Effect.uninterruptible(\n            Effect.tap(\n              acquire,\n              (a) => Ref.set(ref, (exit) => release(a, exit))\n            )\n          )\n        ),\n        core.flatMap(use),\n        core.ensuringWith((exit) => Effect.flatMap(Ref.get(ref), (f) => f(exit)))\n      )\n  )\n\n/** @internal */\nexport const as = dual<\n  <OutDone2>(\n    value: OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    value: OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  value: OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> => map(self, () => value))\n\n/** @internal */\nexport const asVoid = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, void, InDone, Env> => map(self, constVoid)\n\n/** @internal */\nexport const buffer = <InElem, InErr, InDone>(\n  options: {\n    readonly empty: InElem\n    readonly isEmpty: Predicate<InElem>\n    readonly ref: Ref.Ref<InElem>\n  }\n): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n  core.suspend(() => {\n    const doBuffer = <InErr, InElem, InDone>(\n      empty: InElem,\n      isEmpty: Predicate<InElem>,\n      ref: Ref.Ref<InElem>\n    ): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n      unwrap(\n        Ref.modify(ref, (inElem) =>\n          isEmpty(inElem) ?\n            [\n              core.readWith({\n                onInput: (input: InElem) =>\n                  core.flatMap(\n                    core.write(input),\n                    () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n                  ),\n                onFailure: (error: InErr) => core.fail(error),\n                onDone: (done: InDone) => core.succeedNow(done)\n              }),\n              inElem\n            ] as const :\n            [\n              core.flatMap(\n                core.write(inElem),\n                () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n              ),\n              empty\n            ] as const)\n      )\n    return doBuffer(options.empty, options.isEmpty, options.ref)\n  })\n\n/** @internal */\nexport const bufferChunk = <InElem, InErr, InDone>(\n  ref: Ref.Ref<Chunk.Chunk<InElem>>\n): Channel.Channel<Chunk.Chunk<InElem>, Chunk.Chunk<InElem>, InErr, InErr, InDone, InDone> =>\n  buffer({\n    empty: Chunk.empty(),\n    isEmpty: Chunk.isEmpty,\n    ref\n  })\n\n/** @internal */\nexport const catchAll = dual<\n  <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    core.catchAllCause(self, (cause) =>\n      Either.match(Cause.failureOrCause(cause), {\n        onLeft: f,\n        onRight: core.failCause\n      }))\n)\n\n/** @internal */\nexport const concatMap = dual<\n  <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => <Env, InErr, InElem, InDone, OutErr, OutDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >,\n  <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >\n>(2, <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n): Channel.Channel<\n  OutElem2,\n  InElem & InElem2,\n  OutErr | OutErr2,\n  InErr & InErr2,\n  unknown,\n  InDone & InDone2,\n  Env | Env2\n> => core.concatMapWith(self, f, () => void 0, () => void 0))\n\n/** @internal */\nexport const collect = dual<\n  <OutElem, OutElem2>(\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  pf: (o: OutElem) => Option.Option<OutElem2>\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const collector: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (out) =>\n        Option.match(pf(out), {\n          onNone: () => collector,\n          onSome: (out2) => core.flatMap(core.write(out2), () => collector)\n        }),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, collector)\n})\n\n/** @internal */\nexport const concatOut = <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >\n): Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env> => core.concatAll(self)\n\n/** @internal */\nexport const mapInput = dual<\n  <InDone0, InDone>(\n    f: (a: InDone0) => InDone\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InDone0) => InDone\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InDone0) => InDone\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done: InDone0) => core.succeedNow(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <InDone0, InDone, InErr, Env1>(\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done) => core.fromEffect(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputError = dual<\n  <InErr0, InErr>(\n    f: (a: InErr0) => InErr\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InErr0) => InErr\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InErr0) => InErr\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fail(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputErrorEffect = dual<\n  <InErr0, InDone, InErr, Env1>(\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fromEffect(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputIn = dual<\n  <InElem0, InElem>(\n    f: (a: InElem0) => InElem\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => InElem\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => InElem\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(f(inElem)), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputInEffect = dual<\n  <InElem0, InElem, InErr, Env1>(\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => <OutElem, OutErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.flatMap(core.fromEffect(f(inElem)), core.write), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const doneCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env> =>\n  core.suspend(() => {\n    const builder: Array<OutElem> = []\n    return pipe(\n      core.pipeTo(self, doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)),\n      core.flatMap((outDone) => core.succeed([Chunk.unsafeFromArray(builder), outDone]))\n    )\n  })\n\n/** @internal */\nconst doneCollectReader = <Env, OutErr, OutElem, OutDone>(\n  builder: Array<OutElem>\n): Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> => {\n  return core.readWith({\n    onInput: (outElem) =>\n      core.flatMap(\n        core.sync(() => {\n          builder.push(outElem)\n        }),\n        () => doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)\n      ),\n    onFailure: core.fail,\n    onDone: core.succeed\n  })\n}\n\n/** @internal */\nexport const drain = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const drainer: Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWithCause({\n      onInput: () => drainer,\n      onFailure: core.failCause,\n      onDone: core.succeed\n    })\n  return core.pipeTo(self, drainer)\n}\n\n/** @internal */\nexport const emitCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env> =>\n  core.flatMap(doneCollect(self), core.write)\n\n/** @internal */\nexport const ensuring = dual<\n  <Z, Env1>(\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, Z>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  finalizer: Effect.Effect<Z, never, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> =>\n  core.ensuringWith(self, () => finalizer))\n\n/** @internal */\nexport const context = <Env>(): Channel.Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env> =>\n  core.fromEffect(Effect.context<Env>())\n\n/** @internal */\nexport const contextWith = <Env, OutDone>(\n  f: (env: Context.Context<Env>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, Env> => map(context<Env>(), f)\n\n/** @internal */\nexport const contextWithChannel = <\n  Env,\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env1\n>(\n  f: (env: Context.Context<Env>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> => core.flatMap(context<Env>(), f)\n\n/** @internal */\nexport const contextWithEffect = <Env, OutDone, OutErr, Env1>(\n  f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1> => mapEffect(context<Env>(), f)\n\n/** @internal */\nexport const flatten = <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone2,\n  InDone1,\n  Env1,\n  InDone,\n  Env\n>(\n  self: Channel.Channel<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone2,\n  InDone & InDone1,\n  Env | Env1\n> => core.flatMap(self, identity)\n\n/** @internal */\nexport const foldChannel = dual<\n  <\n    OutErr,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutDone,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutElem2,\n  InElem2,\n  OutErr2,\n  InErr2,\n  OutDone2,\n  InDone2,\n  Env2\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly onFailure: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSuccess: (done: OutDone) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n  }\n): Channel.Channel<\n  OutElem | OutElem2 | OutElem1,\n  InElem & InElem1 & InElem2,\n  OutErr2 | OutErr1,\n  InErr & InErr1 & InErr2,\n  OutDone2 | OutDone1,\n  InDone & InDone1 & InDone2,\n  Env | Env1 | Env2\n> =>\n  core.foldCauseChannel(self, {\n    onFailure: (cause) => {\n      const either = Cause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return options.onFailure(either.left)\n        }\n        case \"Right\": {\n          return core.failCause(either.right)\n        }\n      }\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/** @internal */\nexport const fromEither = <R, L>(\n  either: Either.Either<R, L>\n): Channel.Channel<never, unknown, L, unknown, R, unknown> =>\n  core.suspend(() => Either.match(either, { onLeft: core.fail, onRight: core.succeed }))\n\n/** @internal */\nexport const fromInput = <Err, Elem, Done>(\n  input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrap(\n    input.takeWith(\n      core.failCause,\n      (elem) => core.flatMap(core.write(elem), () => fromInput(input)),\n      core.succeed\n    )\n  )\n\n/** @internal */\nexport const fromPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrapScoped(Effect.map(PubSub.subscribe(pubsub), fromQueue))\n\n/** @internal */\nexport const fromPubSubScoped = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Effect.Effect<Channel.Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope> =>\n  Effect.map(PubSub.subscribe(pubsub), fromQueue)\n\n/** @internal */\nexport const fromOption = <A>(\n  option: Option.Option<A>\n): Channel.Channel<never, unknown, Option.Option<never>, unknown, A, unknown> =>\n  core.suspend(() =>\n    Option.match(option, {\n      onNone: () => core.fail(Option.none()),\n      onSome: core.succeed\n    })\n  )\n\n/** @internal */\nexport const fromQueue = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> => core.suspend(() => fromQueueInternal(queue))\n\n/** @internal */\nconst fromQueueInternal = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  pipe(\n    core.fromEffect(Queue.take(queue)),\n    core.flatMap(Either.match({\n      onLeft: Exit.match({\n        onFailure: core.failCause,\n        onSuccess: core.succeedNow\n      }),\n      onRight: (elem) =>\n        core.flatMap(\n          core.write(elem),\n          () => fromQueueInternal(queue)\n        )\n    }))\n  )\n\n/** @internal */\nexport const identityChannel = <Elem, Err, Done>(): Channel.Channel<Elem, Elem, Err, Err, Done, Done> =>\n  core.readWith({\n    onInput: (input: Elem) => core.flatMap(core.write(input), () => identityChannel()),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const interruptWhen = dual<\n  <OutDone1, OutErr1, Env1>(\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  effect: Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env1 | Env> =>\n  mergeWith(self, {\n    other: core.fromEffect(effect),\n    onSelfDone: (selfDone) => mergeDecision.Done(Effect.suspend(() => selfDone)),\n    onOtherDone: (effectDone) => mergeDecision.Done(Effect.suspend(() => effectDone))\n  }))\n\n/** @internal */\nexport const interruptWhenDeferred = dual<\n  <OutDone1, OutErr1>(\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutErr1, OutDone1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  deferred: Deferred.Deferred<OutDone1, OutErr1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env> =>\n  interruptWhen(self, Deferred.await(deferred)))\n\n/** @internal */\nexport const map = dual<\n  <OutDone, OutDone2>(\n    f: (out: OutDone) => OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (out: OutDone) => OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (out: OutDone) => OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> =>\n  core.flatMap(self, (a) => core.sync(() => f(a))))\n\n/** @internal */\nexport const mapEffect = dual<\n  <OutDone, OutDone1, OutErr1, Env1>(\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1> =>\n  core.flatMap(self, (z) => core.fromEffect(f(z))))\n\n/** @internal */\nexport const mapError = dual<\n  <OutErr, OutErr2>(\n    f: (err: OutErr) => OutErr2\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (err: OutErr) => OutErr2\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (err: OutErr) => OutErr2\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> => mapErrorCause(self, Cause.map(f)))\n\n/** @internal */\nexport const mapErrorCause = dual<\n  <OutErr, OutErr2>(\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> =>\n  core.catchAllCause(self, (cause) => core.failCause(f(cause))))\n\n/** @internal */\nexport const mapOut = dual<\n  <OutElem, OutElem2>(\n    f: (o: OutElem) => OutElem2\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => OutElem2\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => OutElem2\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (outElem) => core.flatMap(core.write(f(outElem)), () => reader),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffect = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<OutElem1, OutElem, OutErr | OutErr1, OutErr, OutDone, OutDone, Env | Env1> = core\n    .readWithCause({\n      onInput: (outElem) =>\n        pipe(\n          core.fromEffect(f(outElem)),\n          core.flatMap(core.write),\n          core.flatMap(() => reader)\n        ),\n      onFailure: core.failCause,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffectPar = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n  n: number\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> =>\n  unwrapScopedWith(\n    (scope) =>\n      Effect.gen(function*() {\n        const input = yield* singleProducerAsyncInput.make<InErr, InElem, InDone>()\n        const queueReader = fromInput(input)\n        const queue = yield* Queue.bounded<Effect.Effect<Either.Either<OutElem1, OutDone>, OutErr | OutErr1, Env1>>(n)\n        yield* Scope.addFinalizer(scope, Queue.shutdown(queue))\n        const errorSignal = yield* Deferred.make<never, OutErr1>()\n        const withPermits = n === Number.POSITIVE_INFINITY ?\n          ((_: number) => identity) :\n          (yield* Effect.makeSemaphore(n)).withPermits\n        const pull = yield* queueReader.pipe(core.pipeTo(self), toPullIn(scope))\n        yield* pull.pipe(\n          Effect.matchCauseEffect({\n            onFailure: (cause) => Queue.offer(queue, Effect.failCause(cause)),\n            onSuccess: Either.match({\n              onLeft: (outDone) =>\n                Effect.zipRight(\n                  Effect.interruptible(withPermits(n)(Effect.void)),\n                  Effect.asVoid(Queue.offer(queue, Effect.succeed(Either.left(outDone))))\n                ),\n              onRight: (outElem) =>\n                Effect.gen(function*() {\n                  const deferred = yield* Deferred.make<OutElem1, OutErr1>()\n                  const latch = yield* Deferred.make<void>()\n                  yield* Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right))\n                  yield* Deferred.succeed(latch, void 0).pipe(\n                    Effect.zipRight(\n                      Effect.uninterruptibleMask((restore) =>\n                        Effect.exit(restore(Deferred.await(errorSignal))).pipe(\n                          Effect.raceFirst(Effect.exit(restore(f(outElem)))),\n                          Effect.flatMap(identity)\n                        )\n                      ).pipe(\n                        Effect.tapErrorCause((cause) => Deferred.failCause(errorSignal, cause)),\n                        Effect.intoDeferred(deferred)\n                      )\n                    ),\n                    withPermits(1),\n                    Effect.forkIn(scope)\n                  )\n                  yield* Deferred.await(latch)\n                })\n            })\n          }),\n          Effect.forever,\n          Effect.interruptible,\n          Effect.forkIn(scope)\n        )\n        const consumer: Channel.Channel<OutElem1, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env1> = unwrap(\n          Effect.matchCause(Effect.flatten(Queue.take(queue)), {\n            onFailure: core.failCause,\n            onSuccess: Either.match({\n              onLeft: core.succeedNow,\n              onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n            })\n          })\n        )\n        return core.embedInput(consumer, input)\n      })\n  ))\n\n/** @internal */\nexport const mergeAll = (\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) => {\n  return <\n    OutElem,\n    InElem1,\n    OutErr1,\n    InErr1,\n    InDone1,\n    Env1,\n    InElem,\n    OutErr,\n    InErr,\n    InDone,\n    Env\n  >(\n    channels: Channel.Channel<\n      Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      unknown,\n      InDone,\n      Env\n    >\n  ): Channel.Channel<\n    OutElem,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  > => mergeAllWith(options)(channels, constVoid)\n}\n\n/** @internal */\nexport const mergeAllUnbounded = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    unknown,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, constVoid)\n\n/** @internal */\nexport const mergeAllUnboundedWith = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, f)\n\n/** @internal */\nexport const mergeAllWith = (\n  {\n    bufferSize = 16,\n    concurrency,\n    mergeStrategy = mergeStrategy_.BackPressure()\n  }: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) =>\n<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> =>\n  unwrapScopedWith(\n    (scope) =>\n      Effect.gen(function*() {\n        const concurrencyN = concurrency === \"unbounded\" ? Number.MAX_SAFE_INTEGER : concurrency\n        const input = yield* singleProducerAsyncInput.make<\n          InErr & InErr1,\n          InElem & InElem1,\n          InDone & InDone1\n        >()\n        const queueReader = fromInput(input)\n        const queue = yield* Queue.bounded<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr | OutErr1, Env>>(\n          bufferSize\n        )\n        yield* Scope.addFinalizer(scope, Queue.shutdown(queue))\n        const cancelers = yield* Queue.unbounded<Deferred.Deferred<void>>()\n        yield* Scope.addFinalizer(scope, Queue.shutdown(cancelers))\n        const lastDone = yield* Ref.make<Option.Option<OutDone>>(Option.none())\n        const errorSignal = yield* Deferred.make<void>()\n        const withPermits = (yield* Effect.makeSemaphore(concurrencyN)).withPermits\n        const pull = yield* toPullIn(core.pipeTo(queueReader, channels), scope)\n\n        function evaluatePull(\n          pull: Effect.Effect<\n            Either.Either<OutElem, OutDone>,\n            OutErr | OutErr1,\n            Env | Env1\n          >\n        ) {\n          return pull.pipe(\n            Effect.flatMap(Either.match({\n              onLeft: (done) => Effect.succeed(Option.some(done)),\n              onRight: (outElem) =>\n                Effect.as(\n                  Queue.offer(queue, Effect.succeed(Either.right(outElem))),\n                  Option.none()\n                )\n            })),\n            Effect.repeat({ until: (_): _ is Option.Some<OutDone> => Option.isSome(_) }),\n            Effect.flatMap((outDone) =>\n              Ref.update(\n                lastDone,\n                Option.match({\n                  onNone: () => Option.some(outDone.value),\n                  onSome: (lastDone) => Option.some(f(lastDone, outDone.value))\n                })\n              )\n            ),\n            Effect.catchAllCause((cause) =>\n              Cause.isInterrupted(cause)\n                ? Effect.failCause(cause)\n                : Queue.offer(queue, Effect.failCause(cause)).pipe(\n                  Effect.zipRight(Deferred.succeed(errorSignal, void 0)),\n                  Effect.asVoid\n                )\n            )\n          )\n        }\n\n        yield* pull.pipe(\n          Effect.matchCauseEffect({\n            onFailure: (cause) =>\n              Queue.offer(queue, Effect.failCause(cause)).pipe(\n                Effect.zipRight(Effect.succeed(false))\n              ),\n            onSuccess: Either.match({\n              onLeft: (outDone) =>\n                Effect.raceWith(\n                  Effect.interruptible(Deferred.await(errorSignal)),\n                  Effect.interruptible(withPermits(concurrencyN)(Effect.void)),\n                  {\n                    onSelfDone: (_, permitAcquisition) => Effect.as(Fiber.interrupt(permitAcquisition), false),\n                    onOtherDone: (_, failureAwait) =>\n                      Effect.zipRight(\n                        Fiber.interrupt(failureAwait),\n                        Ref.get(lastDone).pipe(\n                          Effect.flatMap(Option.match({\n                            onNone: () => Queue.offer(queue, Effect.succeed(Either.left(outDone))),\n                            onSome: (lastDone) => Queue.offer(queue, Effect.succeed(Either.left(f(lastDone, outDone))))\n                          })),\n                          Effect.as(false)\n                        )\n                      )\n                  }\n                ),\n              onRight: (channel) =>\n                mergeStrategy_.match(mergeStrategy, {\n                  onBackPressure: () =>\n                    Effect.gen(function*() {\n                      const latch = yield* Deferred.make<void>()\n                      const raceEffects = Effect.scopedWith((scope) =>\n                        toPullIn(core.pipeTo(queueReader, channel), scope).pipe(\n                          Effect.flatMap((pull) =>\n                            Effect.race(\n                              Effect.exit(evaluatePull(pull)),\n                              Effect.exit(Effect.interruptible(Deferred.await(errorSignal)))\n                            )\n                          ),\n                          Effect.flatMap(identity)\n                        )\n                      )\n                      yield* Deferred.succeed(latch, void 0).pipe(\n                        Effect.zipRight(raceEffects),\n                        withPermits(1),\n                        Effect.forkIn(scope)\n                      )\n                      yield* Deferred.await(latch)\n                      const errored = yield* Deferred.isDone(errorSignal)\n                      return !errored\n                    }),\n                  onBufferSliding: () =>\n                    Effect.gen(function*() {\n                      const canceler = yield* Deferred.make<void>()\n                      const latch = yield* Deferred.make<void>()\n                      const size = yield* Queue.size(cancelers)\n                      yield* Queue.take(cancelers).pipe(\n                        Effect.flatMap((canceler) => Deferred.succeed(canceler, void 0)),\n                        Effect.when(() => size >= concurrencyN)\n                      )\n                      yield* Queue.offer(cancelers, canceler)\n                      const raceEffects = Effect.scopedWith((scope) =>\n                        toPullIn(core.pipeTo(queueReader, channel), scope).pipe(\n                          Effect.flatMap((pull) =>\n                            Effect.exit(evaluatePull(pull)).pipe(\n                              Effect.race(Effect.exit(Effect.interruptible(Deferred.await(errorSignal)))),\n                              Effect.race(Effect.exit(Effect.interruptible(Deferred.await(canceler))))\n                            )\n                          ),\n                          Effect.flatMap(identity)\n                        )\n                      )\n                      yield* Deferred.succeed(latch, void 0).pipe(\n                        Effect.zipRight(raceEffects),\n                        withPermits(1),\n                        Effect.forkIn(scope)\n                      )\n                      yield* Deferred.await(latch)\n                      const errored = yield* Deferred.isDone(errorSignal)\n                      return !errored\n                    })\n                })\n            })\n          }),\n          Effect.repeat({ while: (_) => _ }),\n          Effect.forkIn(scope)\n        )\n\n        const consumer: Channel.Channel<OutElem, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env | Env1> =\n          pipe(\n            Queue.take(queue),\n            Effect.flatten,\n            Effect.matchCause({\n              onFailure: core.failCause,\n              onSuccess: Either.match({\n                onLeft: core.succeedNow,\n                onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n              })\n            }),\n            unwrap\n          )\n\n        return core.embedInput(consumer, input)\n      })\n  )\n\n/** @internal */\nexport const mergeMap = dual<\n  <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll(options)(mapOut(self, f)))\n\n/** @internal */\nexport const mergeOut = dual<\n  (\n    n: number\n  ) => <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >,\n    n: number\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(2, <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  n: number\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll({ concurrency: n })(mapOut(self, identity)))\n\n/** @internal */\nexport const mergeOutWith = dual<\n  <OutDone1>(\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >,\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(3, <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone1,\n    InDone,\n    Env\n  >,\n  n: number,\n  f: (o1: OutDone1, o2: OutDone1) => OutDone1\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone1,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: n })(mapOut(self, identity), f))\n\n/** @internal */\nexport const mergeWith = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutErr2,\n    OutDone2,\n    OutErr3,\n    OutDone3\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutErr2,\n  OutDone2,\n  OutErr3,\n  OutDone3\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSelfDone: (\n      exit: Exit.Exit<OutDone, OutErr>\n    ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n    readonly onOtherDone: (\n      ex: Exit.Exit<OutDone1, OutErr1>\n    ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n  }\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr2 | OutErr3,\n  InErr & InErr1,\n  OutDone2 | OutDone3,\n  InDone & InDone1,\n  Env1 | Env\n> => {\n  function merge(scope: Scope.Scope) {\n    return Effect.gen(function*() {\n      type State = MergeState.MergeState<\n        Env | Env1,\n        OutErr,\n        OutErr1,\n        OutErr2 | OutErr3,\n        OutElem | OutElem1,\n        OutDone,\n        OutDone1,\n        OutDone2 | OutDone3\n      >\n\n      const input = yield* singleProducerAsyncInput.make<\n        InErr & InErr1,\n        InElem & InElem1,\n        InDone & InDone1\n      >()\n      const queueReader = fromInput(input)\n      const pullL = yield* toPullIn(core.pipeTo(queueReader, self), scope)\n      const pullR = yield* toPullIn(core.pipeTo(queueReader, options.other), scope)\n\n      function handleSide<Err, Done, Err2, Done2>(\n        exit: Exit.Exit<Either.Either<OutElem | OutElem1, Done>, Err>,\n        fiber: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>,\n        pull: Effect.Effect<Either.Either<OutElem | OutElem1, Done>, Err, Env | Env1>\n      ) {\n        return (\n          done: (\n            ex: Exit.Exit<Done, Err>\n          ) => MergeDecision.MergeDecision<\n            Env | Env1,\n            Err2,\n            Done2,\n            OutErr2 | OutErr3,\n            OutDone2 | OutDone3\n          >,\n          both: (\n            f1: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done>, Err>,\n            f2: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>\n          ) => State,\n          single: (\n            f: (\n              ex: Exit.Exit<Done2, Err2>\n            ) => Effect.Effect<OutDone2 | OutDone3, OutErr2 | OutErr3, Env | Env1>\n          ) => State\n        ): Effect.Effect<\n          Channel.Channel<\n            OutElem | OutElem1,\n            unknown,\n            OutErr2 | OutErr3,\n            unknown,\n            OutDone2 | OutDone3,\n            unknown,\n            Env | Env1\n          >,\n          never,\n          Env | Env1\n        > => {\n          function onDecision(\n            decision: MergeDecision.MergeDecision<\n              Env | Env1,\n              Err2,\n              Done2,\n              OutErr2 | OutErr3,\n              OutDone2 | OutDone3\n            >\n          ): Effect.Effect<\n            Channel.Channel<\n              OutElem | OutElem1,\n              unknown,\n              OutErr2 | OutErr3,\n              unknown,\n              OutDone2 | OutDone3,\n              unknown,\n              Env | Env1\n            >\n          > {\n            const op = decision as mergeDecision.Primitive\n            if (op._tag === MergeDecisionOpCodes.OP_DONE) {\n              return Effect.succeed(\n                core.fromEffect(\n                  Effect.zipRight(\n                    Fiber.interrupt(fiber),\n                    op.effect\n                  )\n                )\n              )\n            }\n            return Effect.map(\n              Fiber.await(fiber),\n              Exit.match({\n                onFailure: (cause) => core.fromEffect(op.f(Exit.failCause(cause))),\n                onSuccess: Either.match({\n                  onLeft: (done) => core.fromEffect(op.f(Exit.succeed(done))),\n                  onRight: (elem) => zipRight(core.write(elem), go(single(op.f)))\n                })\n              })\n            )\n          }\n\n          return Exit.match(exit, {\n            onFailure: (cause) => onDecision(done(Exit.failCause(cause))),\n            onSuccess: Either.match({\n              onLeft: (z) => onDecision(done(Exit.succeed(z))),\n              onRight: (elem) =>\n                Effect.succeed(\n                  core.flatMap(core.write(elem), () =>\n                    core.flatMap(\n                      core.fromEffect(Effect.forkIn(Effect.interruptible(pull), scope)),\n                      (leftFiber) => go(both(leftFiber, fiber))\n                    ))\n                )\n            })\n          })\n        }\n      }\n\n      function go(\n        state: State\n      ): Channel.Channel<\n        OutElem | OutElem1,\n        unknown,\n        OutErr2 | OutErr3,\n        unknown,\n        OutDone2 | OutDone3,\n        unknown,\n        Env | Env1\n      > {\n        switch (state._tag) {\n          case MergeStateOpCodes.OP_BOTH_RUNNING: {\n            const leftJoin = Effect.interruptible(Fiber.join(state.left))\n            const rightJoin = Effect.interruptible(Fiber.join(state.right))\n            return unwrap(\n              Effect.raceWith(leftJoin, rightJoin, {\n                onSelfDone: (leftExit, rf) =>\n                  Effect.zipRight(\n                    Fiber.interrupt(rf),\n                    handleSide(leftExit, state.right, pullL)(\n                      options.onSelfDone,\n                      mergeState.BothRunning,\n                      (f) => mergeState.LeftDone(f)\n                    )\n                  ),\n                onOtherDone: (rightExit, lf) =>\n                  Effect.zipRight(\n                    Fiber.interrupt(lf),\n                    handleSide(rightExit, state.left, pullR)(\n                      options.onOtherDone as (\n                        ex: Exit.Exit<OutDone1, InErr1 | OutErr1>\n                      ) => MergeDecision.MergeDecision<\n                        Env1 | Env,\n                        OutErr,\n                        OutDone,\n                        OutErr2 | OutErr3,\n                        OutDone2 | OutDone3\n                      >,\n                      (left, right) => mergeState.BothRunning(right, left),\n                      (f) => mergeState.RightDone(f)\n                    )\n                  )\n              })\n            )\n          }\n          case MergeStateOpCodes.OP_LEFT_DONE: {\n            return unwrap(\n              Effect.map(\n                Effect.exit(pullR),\n                Exit.match({\n                  onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                  onSuccess: Either.match({\n                    onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                    onRight: (elem) =>\n                      core.flatMap(\n                        core.write(elem),\n                        () => go(mergeState.LeftDone(state.f))\n                      )\n                  })\n                })\n              )\n            )\n          }\n          case MergeStateOpCodes.OP_RIGHT_DONE: {\n            return unwrap(\n              Effect.map(\n                Effect.exit(pullL),\n                Exit.match({\n                  onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                  onSuccess: Either.match({\n                    onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                    onRight: (elem) =>\n                      core.flatMap(\n                        core.write(elem),\n                        () => go(mergeState.RightDone(state.f))\n                      )\n                  })\n                })\n              )\n            )\n          }\n        }\n      }\n\n      return core.fromEffect(\n        Effect.withFiberRuntime<\n          MergeState.MergeState<\n            Env | Env1,\n            OutErr,\n            OutErr1,\n            OutErr2 | OutErr3,\n            OutElem | OutElem1,\n            OutDone,\n            OutDone1,\n            OutDone2 | OutDone3\n          >,\n          never,\n          Env | Env1\n        >((parent) => {\n          const inherit = Effect.withFiberRuntime<void, never, never>((state) => {\n            ;(state as any).transferChildren((parent as any).scope())\n            return Effect.void\n          })\n          const leftFiber = Effect.interruptible(pullL).pipe(\n            Effect.ensuring(inherit),\n            Effect.forkIn(scope)\n          )\n          const rightFiber = Effect.interruptible(pullR).pipe(\n            Effect.ensuring(inherit),\n            Effect.forkIn(scope)\n          )\n          return Effect.zipWith(\n            leftFiber,\n            rightFiber,\n            (left, right): State =>\n              mergeState.BothRunning<\n                Env | Env1,\n                OutErr,\n                OutErr1,\n                OutErr2 | OutErr3,\n                OutElem | OutElem1,\n                OutDone,\n                OutDone1,\n                OutDone2 | OutDone3\n              >(left, right)\n          )\n        })\n      ).pipe(\n        core.flatMap(go),\n        core.embedInput(input)\n      )\n    })\n  }\n  return unwrapScopedWith(merge)\n})\n\n/** @internal */\nexport const never: Channel.Channel<never, unknown, never, unknown, never, unknown> = core.fromEffect(\n  Effect.never\n)\n\n/** @internal */\nexport const orDie = dual<\n  <E>(\n    error: LazyArg<E>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    error: LazyArg<E>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  error: LazyArg<E>\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> => orDieWith(self, error))\n\n/** @internal */\nexport const orDieWith = dual<\n  <OutErr>(\n    f: (e: OutErr) => unknown\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (e: OutErr) => unknown\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (e: OutErr) => unknown\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> =>\n  catchAll(self, (e) => core.failCauseSync(() => Cause.die(f(e)))) as Channel.Channel<\n    OutElem,\n    InElem,\n    never,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >)\n\n/** @internal */\nexport const orElse = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > => catchAll(self, that)\n)\n\n/** @internal */\nexport const pipeToOrFail = dual<\n  <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => <InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n): Channel.Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2> =>\n  core.suspend(() => {\n    let channelException: Channel.ChannelException<OutErr | OutErr2> | undefined = undefined\n\n    const reader: Channel.Channel<OutElem, OutElem, never, OutErr, OutDone, OutDone, Env> = core\n      .readWith({\n        onInput: (outElem) => core.flatMap(core.write(outElem), () => reader),\n        onFailure: (outErr) => {\n          channelException = ChannelException(outErr)\n          return core.failCause(Cause.die(channelException))\n        },\n        onDone: core.succeedNow\n      })\n\n    const writer: Channel.Channel<\n      OutElem2,\n      OutElem2,\n      OutErr2,\n      OutErr2,\n      OutDone2,\n      OutDone2,\n      Env2\n    > = core.readWithCause({\n      onInput: (outElem) => pipe(core.write(outElem), core.flatMap(() => writer)),\n      onFailure: (cause) =>\n        Cause.isDieType(cause) &&\n          isChannelException(cause.defect) &&\n          Equal.equals(cause.defect, channelException)\n          ? core.fail(cause.defect.error as OutErr2)\n          : core.failCause(cause),\n      onDone: core.succeedNow\n    })\n\n    return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer)\n  }))\n\n/** @internal */\nexport const provideService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  tag: Context.Tag<I, S>,\n  service: Types.NoInfer<S>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>> => {\n  return core.flatMap(\n    context<any>(),\n    (context) => core.provideContext(self, Context.add(context, tag, service))\n  )\n})\n\n/** @internal */\nexport const provideLayer = dual<\n  <Env, OutErr2, Env0>(\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  layer: Layer.Layer<Env, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0> =>\n  unwrapScopedWith((scope) =>\n    Effect.map(Layer.buildWithScope(layer, scope), (context) => core.provideContext(self, context))\n  ))\n\n/** @internal */\nexport const mapInputContext = dual<\n  <Env0, Env>(\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (env: Context.Context<Env0>) => Context.Context<Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0> =>\n  contextWithChannel((context: Context.Context<Env0>) => core.provideContext(self, f(context))))\n\n/** @internal */\nexport const provideSomeLayer = dual<\n  <R2, OutErr2, Env0>(\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n  layer: Layer.Layer<R2, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>> =>\n  // @ts-expect-error\n  provideLayer(self, Layer.merge(Layer.context<Exclude<R, R2>>(), layer)))\n\n/** @internal */\nexport const read = <In>(): Channel.Channel<never, In, Option.Option<never>, unknown, In, unknown> =>\n  core.readOrFail<Option.Option<never>, In>(Option.none())\n\n/** @internal */\nexport const repeated = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env> => core.flatMap(self, () => repeated(self))\n\n/** @internal */\nexport const run = <OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env> => Effect.scopedWith((scope) => executor.runIn(self, scope))\n\n/** @internal */\nexport const runCollect = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env> => run(core.collectElements(self))\n\n/** @internal */\nexport const runDrain = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env> => run(drain(self))\n\n/** @internal */\nexport const runScoped = <OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Env | Scope.Scope> => Effect.scopeWith((scope) => executor.runIn(self, scope))\n\n/** @internal */\nexport const scoped = <A, E, R>(\n  effect: Effect.Effect<A, E, R>\n): Channel.Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>> =>\n  unwrap(\n    Effect.uninterruptibleMask((restore) =>\n      Effect.map(Scope.make(), (scope) =>\n        core.acquireReleaseOut(\n          Effect.tapErrorCause(\n            restore(Scope.extend(effect, scope)),\n            (cause) => Scope.close(scope, Exit.failCause(cause))\n          ),\n          (_, exit) => Scope.close(scope, exit)\n        ))\n    )\n  )\n\n/** @internal */\nexport const scopedWith = <A, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>\n): Channel.Channel<A, unknown, E, unknown, unknown, unknown, R> =>\n  unwrapScoped(Effect.map(Effect.scope, (scope) => core.flatMap(core.fromEffect(f(scope)), core.write)))\n\n/** @internal */\nexport const service = <I, S>(\n  tag: Context.Tag<I, S>\n): Channel.Channel<never, unknown, never, unknown, S, unknown, I> => core.fromEffect(tag)\n\n/** @internal */\nexport const serviceWith = <I, S>(tag: Context.Tag<I, S>) =>\n<OutDone>(\n  f: (resource: Types.NoInfer<S>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, I> => map(service(tag), f)\n\n/** @internal */\nexport const serviceWithChannel =\n  <I, S>(tag: Context.Tag<I, S>) =>\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n    f: (resource: Types.NoInfer<S>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | I> => core.flatMap(service(tag), f)\n\n/** @internal */\nexport const serviceWithEffect = <I, S>(tag: Context.Tag<I, S>) =>\n<Env, OutErr, OutDone>(\n  f: (resource: Types.NoInfer<S>) => Effect.Effect<OutDone, OutErr, Env>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | I> => mapEffect(service(tag), f)\n\n/** @internal */\nexport const splitLines = <Err, Done>(): Channel.Channel<\n  Chunk.Chunk<string>,\n  Chunk.Chunk<string>,\n  Err,\n  Err,\n  Done,\n  Done,\n  never\n> =>\n  core.suspend(() => {\n    let stringBuilder = \"\"\n    let midCRLF = false\n    const splitLinesChunk = (chunk: Chunk.Chunk<string>): Chunk.Chunk<string> => {\n      const chunkBuilder: Array<string> = []\n      Chunk.map(chunk, (str) => {\n        if (str.length !== 0) {\n          let from = 0\n          let indexOfCR = str.indexOf(\"\\r\")\n          let indexOfLF = str.indexOf(\"\\n\")\n          if (midCRLF) {\n            if (indexOfLF === 0) {\n              chunkBuilder.push(stringBuilder)\n              stringBuilder = \"\"\n              from = 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              stringBuilder = stringBuilder + \"\\r\"\n            }\n            midCRLF = false\n          }\n          while (indexOfCR !== -1 || indexOfLF !== -1) {\n            if (indexOfCR === -1 || (indexOfLF !== -1 && indexOfLF < indexOfCR)) {\n              if (stringBuilder.length === 0) {\n                chunkBuilder.push(str.substring(from, indexOfLF))\n              } else {\n                chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF))\n                stringBuilder = \"\"\n              }\n              from = indexOfLF + 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              if (str.length === indexOfCR + 1) {\n                midCRLF = true\n                indexOfCR = -1\n              } else {\n                if (indexOfLF === indexOfCR + 1) {\n                  if (stringBuilder.length === 0) {\n                    chunkBuilder.push(str.substring(from, indexOfCR))\n                  } else {\n                    stringBuilder = stringBuilder + str.substring(from, indexOfCR)\n                    chunkBuilder.push(stringBuilder)\n                    stringBuilder = \"\"\n                  }\n                  from = indexOfCR + 2\n                  indexOfCR = str.indexOf(\"\\r\", from)\n                  indexOfLF = str.indexOf(\"\\n\", from)\n                } else {\n                  indexOfCR = str.indexOf(\"\\r\", indexOfCR + 1)\n                }\n              }\n            }\n          }\n          if (midCRLF) {\n            stringBuilder = stringBuilder + str.substring(from, str.length - 1)\n          } else {\n            stringBuilder = stringBuilder + str.substring(from, str.length)\n          }\n        }\n      })\n      return Chunk.unsafeFromArray(chunkBuilder)\n    }\n    const loop: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never> = core\n      .readWithCause({\n        onInput: (input: Chunk.Chunk<string>) => {\n          const out = splitLinesChunk(input)\n          return Chunk.isEmpty(out)\n            ? loop\n            : core.flatMap(core.write(out), () => loop)\n        },\n        onFailure: (cause) =>\n          stringBuilder.length === 0\n            ? core.failCause(cause)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.failCause(cause)),\n        onDone: (done) =>\n          stringBuilder.length === 0\n            ? core.succeed(done)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.succeed(done))\n      })\n    return loop\n  })\n\n/** @internal */\nexport const toPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => toQueue(pubsub)\n\n/** @internal */\nexport const toPull = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env | Scope.Scope> =>\n  Effect.flatMap(Effect.scope, (scope) => toPullIn(self, scope))\n\n/** @internal */\nexport const toPullIn = dual<\n  (scope: Scope.Scope) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    scope: Scope.Scope\n  ) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  scope: Scope.Scope\n) =>\n  Effect.zip(\n    Effect.sync(() => new executor.ChannelExecutor(self, void 0, identity)),\n    Effect.runtime<Env>()\n  ).pipe(\n    Effect.tap(([executor, runtime]) =>\n      Scope.addFinalizerExit(scope, (exit) => {\n        const finalizer = executor.close(exit)\n        return finalizer !== undefined\n          ? Effect.provide(finalizer, runtime)\n          : Effect.void\n      })\n    ),\n    Effect.uninterruptible,\n    Effect.map(([executor]) =>\n      Effect.suspend(() =>\n        interpretToPull(\n          executor.run() as ChannelState.ChannelState<OutErr, Env>,\n          executor\n        )\n      )\n    )\n  ))\n\n/** @internal */\nconst interpretToPull = <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n  channelState: ChannelState.ChannelState<OutErr, Env>,\n  exec: executor.ChannelExecutor<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> => {\n  const state = channelState as ChannelState.Primitive\n  switch (state._tag) {\n    case ChannelStateOpCodes.OP_DONE: {\n      return Exit.match(exec.getDone(), {\n        onFailure: Effect.failCause,\n        onSuccess: (done): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> =>\n          Effect.succeed(Either.left(done))\n      })\n    }\n    case ChannelStateOpCodes.OP_EMIT: {\n      return Effect.succeed(Either.right(exec.getEmit()))\n    }\n    case ChannelStateOpCodes.OP_FROM_EFFECT: {\n      return pipe(\n        state.effect as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>,\n        Effect.flatMap(() => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec))\n      )\n    }\n    case ChannelStateOpCodes.OP_READ: {\n      return executor.readUpstream(\n        state,\n        () => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec),\n        (cause) => Effect.failCause(cause) as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>\n      )\n    }\n  }\n}\n\n/** @internal */\nexport const toQueue = <Done, Err, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => core.suspend(() => toQueueInternal(queue))\n\n/** @internal */\nconst toQueueInternal = <Err, Done, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => {\n  return core.readWithCause({\n    onInput: (elem) =>\n      core.flatMap(\n        core.fromEffect(Queue.offer(queue, Either.right(elem))),\n        () => toQueueInternal(queue)\n      ),\n    onFailure: (cause) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.failCause(cause))))),\n    onDone: (done) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.succeed(done)))))\n  })\n}\n\n/** @internal */\nexport const unwrap = <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(\n  channel: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2> => flatten(core.fromEffect(channel))\n\n/** @internal */\nexport const unwrapScoped = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(\n  self: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>> =>\n  core.concatAllWith(\n    scoped(self),\n    (d, _) => d,\n    (d, _) => d\n  )\n\n/** @internal */\nexport const unwrapScopedWith = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env> =>\n  core.concatAllWith(\n    scopedWith(f),\n    (d, _) => d,\n    (d, _) => d\n  )\n\n/** @internal */\nexport const updateService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>,\n  <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n    tag: Context.Tag<I, S>,\n    f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>\n>(3, <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n  tag: Context.Tag<I, S>,\n  f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>\n): Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R | I> =>\n  mapInputContext(self, (context: Context.Context<R>) =>\n    Context.merge(\n      context,\n      Context.make(tag, f(Context.unsafeGet(context, tag)))\n    )))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions\n  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    name: string,\n    options?: Tracer.SpanOptions\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  const acquire = Effect.all([\n    Effect.makeSpan(name, options),\n    Effect.context(),\n    Effect.clock,\n    FiberRef.get(FiberRef.currentTracerTimingEnabled)\n  ])\n  if (dataFirst) {\n    const self = arguments[0]\n    return acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n  }\n  return (self: Channel.Channel<any>) =>\n    acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n} as any\n\n/** @internal */\nexport const writeAll = <OutElem>(\n  ...outs: Array<OutElem>\n): Channel.Channel<OutElem> => writeChunk(Chunk.fromIterable(outs))\n\n/** @internal */\nexport const writeChunk = <OutElem>(\n  outs: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => writeChunkWriter(0, outs.length, outs)\n\n/** @internal */\nconst writeChunkWriter = <OutElem>(\n  idx: number,\n  len: number,\n  chunk: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => {\n  return idx === len\n    ? core.void\n    : pipe(\n      core.write(pipe(chunk, Chunk.unsafeGet(idx))),\n      core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))\n    )\n}\n\n/** @internal */\nexport const zip = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      mergeWith(self, {\n        other: that,\n        onSelfDone: (exit1) => mergeDecision.Await((exit2) => Effect.suspend(() => Exit.zip(exit1, exit2))),\n        onOtherDone: (exit2) => mergeDecision.Await((exit1) => Effect.suspend(() => Exit.zip(exit1, exit2)))\n      }) :\n      core.flatMap(self, (a) => map(that, (b) => [a, b] as const))\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[0]) :\n      core.flatMap(self, (z) => as(that, z))\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[1]) :\n      core.flatMap(self, () => that)\n)\n\n/** @internal */\nexport const ChannelExceptionTypeId: Channel.ChannelExceptionTypeId = Symbol.for(\n  \"effect/Channel/ChannelException\"\n) as Channel.ChannelExceptionTypeId\n\n/** @internal */\nexport const ChannelException = <E>(error: E): Channel.ChannelException<E> => ({\n  _tag: \"ChannelException\",\n  [ChannelExceptionTypeId]: ChannelExceptionTypeId,\n  error\n})\n\n/** @internal */\nexport const isChannelException = (u: unknown): u is Channel.ChannelException<unknown> =>\n  hasProperty(u, ChannelExceptionTypeId)\n"],"names":["Cause","Chunk","Context","Deferred","Effect","Either","Equal","Exit","Fiber","FiberRef","constVoid","dual","identity","pipe","Layer","Option","hasProperty","PubSub","Queue","Ref","Scope","executor","mergeDecision","mergeState","mergeStrategy_","singleProducerAsyncInput","coreEffect","core","MergeDecisionOpCodes","MergeStateOpCodes","ChannelStateOpCodes","tracer","acquireUseRelease","acquire","use","release","flatMap","fromEffect","make","void","ref","uninterruptible","tap","a","set","exit","ensuringWith","get","f","as","self","value","map","asVoid","buffer","options","suspend","doBuffer","empty","isEmpty","unwrap","modify","inElem","readWith","onInput","input","write","onFailure","error","fail","onDone","done","succeedNow","bufferChunk","catchAll","catchAllCause","cause","match","failureOrCause","onLeft","onRight","failCause","concatMap","concatMapWith","collect","pf","collector","out","onNone","onSome","out2","pipeTo","concatOut","concatAll","mapInput","reader","mapInputEffect","mapInputError","mapInputErrorEffect","mapInputIn","mapInputInEffect","doneCollect","builder","doneCollectReader","outDone","succeed","unsafeFromArray","outElem","sync","push","drain","drainer","readWithCause","emitCollect","ensuring","finalizer","context","contextWith","contextWithChannel","contextWithEffect","mapEffect","flatten","foldChannel","foldCauseChannel","either","_tag","left","right","onSuccess","fromEither","fromInput","takeWith","elem","fromPubSub","pubsub","unwrapScoped","subscribe","fromQueue","fromPubSubScoped","fromOption","option","none","queue","fromQueueInternal","take","identityChannel","interruptWhen","effect","mergeWith","other","onSelfDone","selfDone","Done","onOtherDone","effectDone","interruptWhenDeferred","deferred","await","z","mapError","mapErrorCause","mapOut","mapOutEffect","mapOutEffectPar","n","unwrapScopedWith","scope","gen","queueReader","bounded","addFinalizer","shutdown","errorSignal","withPermits","Number","POSITIVE_INFINITY","_","makeSemaphore","pull","toPullIn","matchCauseEffect","offer","zipRight","interruptible","latch","uninterruptibleMask","restore","raceFirst","tapErrorCause","intoDeferred","forkIn","forever","consumer","matchCause","embedInput","mergeAll","channels","mergeAllWith","mergeAllUnbounded","concurrency","mergeAllUnboundedWith","bufferSize","mergeStrategy","BackPressure","concurrencyN","MAX_SAFE_INTEGER","cancelers","unbounded","lastDone","evaluatePull","some","repeat","until","isSome","update","isInterrupted","raceWith","permitAcquisition","interrupt","failureAwait","channel","onBackPressure","raceEffects","scopedWith","race","errored","isDone","onBufferSliding","canceler","size","when","while","mergeMap","mergeOut","mergeOutWith","merge","pullL","pullR","handleSide","fiber","both","single","onDecision","decision","op","OP_DONE","go","leftFiber","state","OP_BOTH_RUNNING","leftJoin","join","rightJoin","leftExit","rf","BothRunning","LeftDone","rightExit","lf","RightDone","OP_LEFT_DONE","OP_RIGHT_DONE","withFiberRuntime","parent","inherit","transferChildren","rightFiber","zipWith","never","orDie","orDieWith","e","failCauseSync","die","orElse","that","pipeToOrFail","channelException","undefined","outErr","ChannelException","writer","isDieType","isChannelException","defect","equals","provideService","tag","service","provideContext","add","provideLayer","layer","buildWithScope","mapInputContext","provideSomeLayer","read","readOrFail","repeated","run","runIn","runCollect","collectElements","runDrain","runScoped","scopeWith","scoped","acquireReleaseOut","extend","close","serviceWith","serviceWithChannel","serviceWithEffect","splitLines","stringBuilder","midCRLF","splitLinesChunk","chunk","chunkBuilder","str","length","from","indexOfCR","indexOf","indexOfLF","substring","loop","of","toPubSub","toQueue","toPull","zip","ChannelExecutor","runtime","addFinalizerExit","provide","interpretToPull","channelState","exec","getDone","OP_EMIT","getEmit","OP_FROM_EFFECT","OP_READ","readUpstream","toQueueInternal","concatAllWith","d","updateService","unsafeGet","withSpan","dataFirst","arguments","name","addSpanStackTrace","all","makeSpan","clock","currentTracerTimingEnabled","span","spanTag","timingEnabled","endSpan","writeAll","outs","writeChunk","fromIterable","writeChunkWriter","idx","len","args","isChannel","concurrent","exit1","Await","exit2","b","zipLeft","tuple","ChannelExceptionTypeId","Symbol","for","u"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}