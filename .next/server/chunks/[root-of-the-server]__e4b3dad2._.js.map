{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///Users/nathan/Desktop/next/showStack/app/api/auth/upload/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { writeFile, mkdir } from \"fs/promises\";\nimport { join } from \"path\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { existsSync } from \"fs\";\n\nexport async function POST(request: Request) {\n  try {\n    // Traiter le formulaire\n    const formData = await request.formData();\n    const file = formData.get(\"file\") as File | null;\n\n    if (!file) {\n      return NextResponse.json(\n        { error: \"Aucun fichier n'a été envoyé\" },\n        { status: 400 }\n      );\n    }\n\n    // Valider le type de fichier\n    if (!file.type.startsWith(\"image/\")) {\n      return NextResponse.json(\n        { error: \"Le fichier doit être une image\" },\n        { status: 400 }\n      );\n    }\n\n    // Générer un nom de fichier unique\n    const fileExtension = file.name.split(\".\").pop();\n    const fileName = `${uuidv4()}.${fileExtension}`;\n\n    // Créer le chemin de sauvegarde\n    const publicDir = join(process.cwd(), \"public\");\n    const uploadsDir = join(publicDir, \"uploads\");\n    const avatarsDir = join(uploadsDir, \"avatars\");\n\n    // S'assurer que les dossiers existent\n    if (!existsSync(uploadsDir)) {\n      await mkdir(uploadsDir, { recursive: true });\n    }\n    if (!existsSync(avatarsDir)) {\n      await mkdir(avatarsDir, { recursive: true });\n    }\n\n    // Convertir le fichier en buffer\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n\n    // Écrire le fichier\n    const filePath = join(avatarsDir, fileName);\n    await writeFile(filePath, buffer);\n\n    // URL relative pour stocker en base de données\n    const imageUrl = `/uploads/avatars/${fileName}`;\n\n    return NextResponse.json({\n      message: \"Image téléchargée avec succès\",\n      imageUrl,\n    });\n  } catch (error) {\n    console.error(\"Erreur lors de l'upload de l'image:\", error);\n    return NextResponse.json(\n      { error: \"Erreur interne du serveur\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,wBAAwB;QACxB,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,IAAI,CAAC,MAAM;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+B,GACxC;gBAAE,QAAQ;YAAI;QAElB;QAEA,6BAA6B;QAC7B,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,WAAW;YACnC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiC,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,mCAAmC;QACnC,MAAM,gBAAgB,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG;QAC9C,MAAM,WAAW,GAAG,CAAA,GAAA,4KAAA,CAAA,KAAM,AAAD,IAAI,CAAC,EAAE,eAAe;QAE/C,gCAAgC;QAChC,MAAM,YAAY,CAAA,GAAA,iGAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,GAAG,IAAI;QACtC,MAAM,aAAa,CAAA,GAAA,iGAAA,CAAA,OAAI,AAAD,EAAE,WAAW;QACnC,MAAM,aAAa,CAAA,GAAA,iGAAA,CAAA,OAAI,AAAD,EAAE,YAAY;QAEpC,sCAAsC;QACtC,IAAI,CAAC,CAAA,GAAA,6FAAA,CAAA,aAAU,AAAD,EAAE,aAAa;YAC3B,MAAM,CAAA,GAAA,qHAAA,CAAA,QAAK,AAAD,EAAE,YAAY;gBAAE,WAAW;YAAK;QAC5C;QACA,IAAI,CAAC,CAAA,GAAA,6FAAA,CAAA,aAAU,AAAD,EAAE,aAAa;YAC3B,MAAM,CAAA,GAAA,qHAAA,CAAA,QAAK,AAAD,EAAE,YAAY;gBAAE,WAAW;YAAK;QAC5C;QAEA,iCAAiC;QACjC,MAAM,QAAQ,MAAM,KAAK,WAAW;QACpC,MAAM,SAAS,OAAO,IAAI,CAAC;QAE3B,oBAAoB;QACpB,MAAM,WAAW,CAAA,GAAA,iGAAA,CAAA,OAAI,AAAD,EAAE,YAAY;QAClC,MAAM,CAAA,GAAA,qHAAA,CAAA,YAAS,AAAD,EAAE,UAAU;QAE1B,+CAA+C;QAC/C,MAAM,WAAW,CAAC,iBAAiB,EAAE,UAAU;QAE/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}